{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#do-i-need-to-use-the-python-script-to-generate-the-hdf-file","title":"Do I need to use the python script to generate the HDF file?","text":"<p>No. Advanced users can analyse the structure of the HDF file and construct their own HDF file as an input to run KITE. </p>"},{"location":"faq/#why-do-we-need-a-post-processing-tool-it-could-be-easier-to-have-a-single-code-to-directly-calculate-the-quantities","title":"Why do we need a post-processing tool? It could be easier to have a single code to directly calculate the quantities.","text":"<p>One of the main advantages of a Chebyshev expansion is the possibility to obtain new values of a given quantity without having to recalculate the Chebyshev expansion. This is the case, for example, of the DC and optical conductivities. One can use the same Chebyshev expansion to obtain these two quantities at different temperatures or the optical conductivity for a set of Fermi energies. KITE is structured to take advantage of this possibility. KITEx calculates the Chebyshev expansion while KITE-tools uses the expansion to obtain these quantities while allowing the user to change several parameters without the need to recalculate the terms of the expansion.</p>"},{"location":"faq/#what-are-the-units-of-the-magnetic-field","title":"What are the units of the magnetic field?","text":"<p>KITE assumes the lattice constants of the tight-binding model are provided in nanometers (nm) and the magnetic field is given in Tesla. If the user consider other units for the lattice constant, the magnetic field is rescaled according to the definition of magnetic flux per unit cell. </p>"},{"location":"faq/#what-are-the-units-of-the-temperature","title":"What are the units of the temperature?","text":"<p>For KITE, the temperature parameter is given in units of energy (\\(k_B T\\)) and follows the definition of the hopping parameters. To convert to Kelvins, the user needs to devide KITE's temperature by \\(k_B T\\).</p>"},{"location":"faq/#how-to-cite-kite","title":"How to cite KITE:","text":"<pre><code>@ARTICLE{Joao2020,\n  title     = \"{KITE}: high-performance accurate modelling of electronic\n               structure and response functions of large molecules, disordered\n               crystals and heterostructures\",\n  author    = \"Jo{\\~a}o, Sim{\\~a}o M. and An\u0111elkovi{\\'c}, Mi{\\v s}a and Covaci, \n               Lucian and Rappoport, Tatiana G. and Lopes, Jo{\\~a}o M. V. P. and Ferreira, Aires\",\n  publisher = \"R. Soc. open sci.\",\n  volume    = \"7\",\n  number    = \"2\",\n  pages     = \"191809\",\n  year      = \"2020\",\n  url = {https://royalsocietypublishing.org/doi/abs/10.1098/rsos.191809}\n  keywords  = \"Chebyshev expansions; electronic structure; disorder; optical\n               response; quantum transport; tight-binding methods\",\n  language  = \"en\"}\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>KITE is written in C++ with code optimized for large systems and optimal multithreading performance.  Pybinding is KITE's default interface,  which is primarily used to build the configuration (HDF5) file for KITEx.</p> <p>The KITE team endeavours to assist researchers run KITE on UNIX-based systems, such as GNU/Linux and Mac OS X. Thus, feel free to contact any of our team members if you have any queries (contacts can be found at the bottom of the landing page). </p> <p>In what follows, we provide detailed installation instructions and additional tips for both Linux and MAC users. </p>"},{"location":"installation/#1-download-kite","title":"1. Download KITE","text":"<p>First download the source code from our official repository on GitHub repository:</p> <pre><code>git clone https://github.com/quantum-kite/kite.git\n</code></pre> <p>Info</p> <p>Git's installation process for Mac users is outlined in section 2.2.</p>"},{"location":"installation/#2-get-dependencies","title":"2. Get dependencies","text":"<ul> <li>Pybinding</li> <li>Eigen3 (version 3.3.7 or newer)</li> <li>HDF5 (version 1.8.13 or newer)</li> <li>CMake (version 3.9 or newer)</li> <li>gcc (version 4.8.1 or newer)</li> <li>h5py</li> </ul> <p>(See detailed instructions below.)</p> <p>The compiler must support C++17 (or newer) features and OpenMP parallelization. </p> <p>To enable KITE's Gaussian wavepacket propagation functionality, compile the source code with a recent gcc version (gcc 8.0.0 or newer). To check the gcc version, you can use the following command in the terminal:</p> <pre><code>g++ --version\n</code></pre>"},{"location":"installation/#21-for-ubuntu-users","title":"2.1 For Ubuntu users","text":"<p>Install Eigen3 for various linear algebra tools:</p> <pre><code>sudo apt-get install libeigen3-dev\n</code></pre> <p>Make sure you retrieve the latest stable release of Eigen3. Unzip the file and copy the Eigen directory to /usr/include/.</p> <p>Hierarchical Data Format (HDF5) is used to store the inputs/outputs of the program:</p> <pre><code>sudo apt-get install h5utils\nsudo apt-get install libhdf5-dev\n</code></pre> <p>Calculations on KITE are configured using a python script which interfaces with Pybinding. Pybinding requires CMake:</p> <pre><code>sudo apt-get install cmake\n</code></pre> <p>Next, install Pybinding dependencies: </p> <pre><code>pip install numpy scipy matplotlib pytest\n</code></pre> <p>Install pybinding using pip:</p> <pre><code>pip install -i https://test.pypi.org/simple/ pybinding\n</code></pre> <p>To construct the HDF5-files, KITE requires h5py: </p> <pre><code>pip install h5py\n</code></pre>"},{"location":"installation/#22-for-mac-os-x-users","title":"2.2 For Mac OS X users","text":"<p>The installation of KITE's dependencies on Apple machines is slightly more evolved. We provide below a recipe that has been tested on some Mac OS X systems, but users are encouraged to contact the KITE team shall they encounter any difficulties.  </p> <p>The Xcode command-line tools from Apple Developer are required.  Install these using the terminal:</p> <pre><code>xcode-select --install\n</code></pre> <p>KITE requires an open-source software package management system like Homebrew or MacPorts. We provide here step-by-step instructions for Homebrew (pointers for MacPorts users are given below). To install HomeBrew, run the following command in the terminal and follow the subsequent instructions provided by software:</p> <pre><code>/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n</code></pre> <p>Install an up-to-date C++ compiler via Homebrew:</p> <pre><code>brew install gcc\n</code></pre> <p>Now close the terminal window, and open a new terminal window.</p> <p>Info</p> <ol> <li> <p>The default directory for Homebrew is /usr/local/bin/.     Correct this path if Homebrew was installed in a different directory</p> </li> <li> <p>In the following sections, replace n with the version of gcc installed by Homebrew as given by <code>brew info gcc</code>.</p> </li> </ol> <p>The hierarchical Data Format (HDF5) is used to store the inputs/outputs of the program. Install HDF5 from source, whilst enforcing the C++17 standard, using:</p> <pre><code>HOMEBREW_CC=gcc-n HOMEBREW_CXX=g++-n HOMEBREW_CXXFLAGS=\"-std=c++17\" brew install hdf5 --build-from-source\n</code></pre> <p>Info</p> <p>MacPorts users can use the following command:</p> <pre><code>sudo port -v install hdf5 +gcc-n +cxx +hl configure.ldflags=\"-stdlib=libstdc++\" configure.cxx_stdlib=\"libstdc++\" configure.cxxflags=\"-std=c++17\" \n</code></pre> <p>Install Eigen3 for various linear algebra tools, CMake and Python:</p> <pre><code>brew install eigen python Cmake git\n</code></pre> <p>Calculations on KITE are configured using a python script which interfaces with Pybinding. Pybinding also requires the SciPy packages but pip will resolve all the SciPy dependencies automatically:</p> <p>Warning</p> <p>To install the pyhton requirements, you must run the Homebrew-python version. You can find the Homebrew-python binary at <code>/opt/homebrew/bin/python3</code>.</p> <pre><code>/usr/local/bin/python3 -m pip install numpy h5py pybinding\n</code></pre> <p>Install pybinding using pip:</p> <pre><code>pip install -i https://test.pypi.org/simple/ pybinding\n</code></pre> <p>Next, download the source code by the command given in section 1. Edit CMakeLists.txt in the <code>kite/</code>-directory:</p> <ul> <li> <p>locate the following statements   <pre><code>set(CMAKE C COMPILER \"gcc\")\nset(CMAKE CXX COMPILER \"g++\")\n</code></pre></p> </li> <li> <p>replace by   <pre><code>set(CMAKE C COMPILER \"gcc-n\")\nset(CMAKE CXX COMPILER \"g++-n\")\n</code></pre></p> </li> </ul> <p>where n is the version number as used previously.</p>"},{"location":"installation/#3-kitex-kite-tools","title":"3. KITEx &amp; KITE-tools","text":"<p>From within the <code>kite/</code> directory (containing CMakeLists.txt and kite.py), run the following commands:</p> <pre><code>mkdir build\ncd build\ncmake ..\nmake\n</code></pre> <p>Info</p> <p>Any warnings appearing during the compilation process can typically be ignored.</p> <p>If these commands have run successfully, you will now find KITEx and KITE-tools  in the <code>kite/build/</code> directory, which are now ready to use!</p>"},{"location":"installation/#4-test-kite","title":"4. Test KITE","text":"<p>To generate an input file using KITE's python-interface, try one of our examples in the <code>kite/examples/</code> directory:</p> <pre><code>python dos_graphene.py\n</code></pre> <p>It creates a file named graphene_lattice-output.h5 that is used as an input for KITEx:</p> <pre><code>../build/KITEx graphene_lattice-output.h5\n</code></pre> <p>This first example calculates the density of states (DOS) of pristine graphene. To obtain the file with the DOS-data, you need to post-process the output with  </p> <pre><code>../build/KITE-tools graphene_lattice-output.h5\n</code></pre> <p>which generates the appropriate data file. For more details refer to the tutorial.</p>"},{"location":"installation/#5-common-issues","title":"5. Common issues","text":""},{"location":"installation/#51-finding-eigen3-with-cmake","title":"5.1 Finding Eigen3 with CMake","text":"<p>If experiencing difficulties running <code>cmake..</code> due to CMake not being able to locate Eigen3, you may opt for the following solution. Extract Eigen3 from source and then run the following command from Eigen3's directory</p> <p><pre><code>mkdir build\ncd build\ncmake ..\nmake\n</code></pre> You may now wish to try and re-compile KITEx and KITE-tools following the steps of Sec. 3.</p>"},{"location":"installation/#52-apple-silicon-arm-architecture","title":"5.2 Apple Silicon (ARM) architecture","text":"<p>On machines from the Apple Silicon lineup (M1, M1Max, etc.) you may have to use the Rosetta translator if experiencing architecture compatibility issues. Rosetta simulates an Intel-x64 system and translates existing software for use with Apple Silicon.  To load Rosetta, run <code>arch -x86_64 zsh</code> when starting a new terminal.</p>"},{"location":"about/","title":"About KITE","text":"<p>Quantum KITE is an open-source Python/C++ software suite for efficient real-space tight-binding (TB) simulations of electronic structure and bulk quantum transport properties of disordered systems scalable to multi billions of atomic orbitals.</p> <p>KITE v1.1 (this version) is shipped with the following capabilities:</p> <ul> <li>Quantum Transport: longitudinal and transverse DC conductivities at zero and finite temperature;</li> <li>Optical Properties: AC longitudinal conductivity;</li> <li>Optical Properties: nonlinear optical susceptibility;</li> <li>Unitary time evolution: Gaussian wave-packet propagation (diffusion);</li> <li>Electronic Structure: high-resolution density of states (DoS);</li> <li>Electronic Structure: local DoS (LDoS) and ARPES;</li> <li>Special Features: automated magnetic field in 2D;</li> <li>Special Features: lattice perturbations (e.g., strain) and \u2018disorder cell\u2019 concept for implementation of multi-orbital/-bond impurities;</li> <li>Algorithms: high-resolution CPGF full spectral (DoS);</li> <li>Algorithms: high-resolution CPGF full spectral (finite temperature response functions);</li> <li>Algorithms: high-resolution CPGF single-shot (zero temperature DC conductivity)</li> </ul> <p>New functionalities in v1.1:</p> <ul> <li>Algorithms: High-resolution CPGF single-shot algorithm extended to handle multiple Fermi energies simultaneously  </li> <li>Special features: twisted boundary conditions for arbitrary lattice models</li> <li>Special features: customized on-site potential landscapes</li> <li>Special features: automated magnetic field in 3D cubic systems</li> </ul> <p>For further details on the algorithms and the implementation please refer to S. M. Joao et al., R. Soc. Open Sci. 7, 191809 (2020) [https://royalsocietypublishing.org/doi/full/10.1098/rsos.191809].</p>"},{"location":"about/#getting-started","title":"Getting Started","text":"<p>For installation instructions and an overview of the main functionalities of KITE, please refer the documentation online Getting Started. Advanced examples are explained in Examples. After downloading the repository, you can find a copy of the tutorial scripts under the examples folder.</p>"},{"location":"about/#prerequisites","title":"Prerequisites","text":"<p>Before installing the core components, KITEx and KITE-tools, the following prerequisites need to be satisfied:</p> <ul> <li> <p>Eigen3</p> </li> <li> <p>Python (version 3.5 or newer)</p> </li> <li> <p>HDF5 (version 1.8.13 or newer)</p> </li> <li> <p>Pybinding (see the requirements)</p> </li> <li> <p>GCC compiler (version 4.8.1 or newer, for the wavepacket functionality gcc 8.0 is needed)</p> </li> <li> <p>CMake</p> </li> <li> <p>Make.</p> </li> </ul>"},{"location":"about/#installation","title":"Installation","text":"<p>After meeting prerequisites and downloading the repository, you can compile KITE using the already available Cmake files. Please check the Cmake files first, and make any necessary edits to the libraries/packages' paths. For step by step instructions, please refer to the Installation section.</p>"},{"location":"about/#license","title":"License","text":"<p>This project is licensed under the GPL v3 License - see the LICENSE.md file for details</p>"},{"location":"about/#project-founders","title":"Project founders","text":"<p>Sim\u00e3o M. Jo\u00e3o, Jo\u00e3o V. Lopes (Universidade do Porto, Portugal), Tatiana G. Rappoport (Universidade Federal Rio de Janeiro, Brazil), Mi\u0161a An\u0111elkovi\u0107, Lucian Covaci (University of Antwerp, Belgium) and Aires Ferreira (University of York, UK).</p>"},{"location":"about/#contributors","title":"Contributors","text":"<ul> <li>KITEx/KITE-tools development: Jo\u00e3o P. Santos Pires (Porto)</li> <li>Python interface / documentation: Bert Jorissen (Antwerp), Emile Aerts (Antwerp), Robin Smeyers (Antwerp), David T. S. Perkins (York)</li> </ul> <p>If you would like to collaborate with us on the KITE project, please email a team member directly.</p>"},{"location":"about/#acknowledgments","title":"Acknowledgments","text":"<p>The inception of KITE's open-source project was funded by The Royal Society through grant NA150043 \"Efficient Numerical Solver for Spin, Charge and Optical Conductivity\" (T. Rappoport and A. Ferreira). The KITE team is also grateful for the support received from EPSRC (A. Ferreira), The Royal Society (UF130385, A. Ferreira) and FLAG-ERA (TRANS2DTMD, M. An\u0111elkovi\u0107 and L. Covaci). We thank Miguel Dias Costa (HPC at NUS, Singapore), Killian Murphy (HPC at University of York, UK) and Julia Giannella (Web Design) for the technical support provided in the early stages of the KITE project.</p>"},{"location":"about/LICENSE/","title":"LICENSE.md","text":"<pre><code>               GNU LESSER GENERAL PUBLIC LICENSE\n                   Version 3, 29 June 2007\n</code></pre> <p>Copyright (C) 2007 Free Software Foundation, Inc. http://fsf.org/  Everyone is permitted to copy and distribute verbatim copies  of this license document, but changing it is not allowed.</p> <p>This version of the GNU Lesser General Public License incorporates the terms and conditions of version 3 of the GNU General Public License, supplemented by the additional permissions listed below.</p> <ol> <li>Additional Definitions.</li> </ol> <p>As used herein, \"this License\" refers to version 3 of the GNU Lesser General Public License, and the \"GNU GPL\" refers to version 3 of the GNU General Public License.</p> <p>\"The Library\" refers to a covered work governed by this License, other than an Application or a Combined Work as defined below.</p> <p>An \"Application\" is any work that makes use of an interface provided by the Library, but which is not otherwise based on the Library. Defining a subclass of a class defined by the Library is deemed a mode of using an interface provided by the Library.</p> <p>A \"Combined Work\" is a work produced by combining or linking an Application with the Library.  The particular version of the Library with which the Combined Work was made is also called the \"Linked Version\".</p> <p>The \"Minimal Corresponding Source\" for a Combined Work means the Corresponding Source for the Combined Work, excluding any source code for portions of the Combined Work that, considered in isolation, are based on the Application, and not on the Linked Version.</p> <p>The \"Corresponding Application Code\" for a Combined Work means the object code and/or source code for the Application, including any data and utility programs needed for reproducing the Combined Work from the Application, but excluding the System Libraries of the Combined Work.</p> <ol> <li>Exception to Section 3 of the GNU GPL.</li> </ol> <p>You may convey a covered work under sections 3 and 4 of this License without being bound by section 3 of the GNU GPL.</p> <ol> <li>Conveying Modified Versions.</li> </ol> <p>If you modify a copy of the Library, and, in your modifications, a facility refers to a function or data to be supplied by an Application that uses the facility (other than as an argument passed when the facility is invoked), then you may convey a copy of the modified version:</p> <p>a) under this License, provided that you make a good faith effort to    ensure that, in the event an Application does not supply the    function or data, the facility still operates, and performs    whatever part of its purpose remains meaningful, or</p> <p>b) under the GNU GPL, with none of the additional permissions of    this License applicable to that copy.</p> <ol> <li>Object Code Incorporating Material from Library Header Files.</li> </ol> <p>The object code form of an Application may incorporate material from a header file that is part of the Library.  You may convey such object code under terms of your choice, provided that, if the incorporated material is not limited to numerical parameters, data structure layouts and accessors, or small macros, inline functions and templates (ten or fewer lines in length), you do both of the following:</p> <p>a) Give prominent notice with each copy of the object code that the    Library is used in it and that the Library and its use are    covered by this License.</p> <p>b) Accompany the object code with a copy of the GNU GPL and this license    document.</p> <ol> <li>Combined Works.</li> </ol> <p>You may convey a Combined Work under terms of your choice that, taken together, effectively do not restrict modification of the portions of the Library contained in the Combined Work and reverse engineering for debugging such modifications, if you also do each of the following:</p> <p>a) Give prominent notice with each copy of the Combined Work that    the Library is used in it and that the Library and its use are    covered by this License.</p> <p>b) Accompany the Combined Work with a copy of the GNU GPL and this license    document.</p> <p>c) For a Combined Work that displays copyright notices during    execution, include the copyright notice for the Library among    these notices, as well as a reference directing the user to the    copies of the GNU GPL and this license document.</p> <p>d) Do one of the following:</p> <pre><code>   0) Convey the Minimal Corresponding Source under the terms of this\n   License, and the Corresponding Application Code in a form\n   suitable for, and under terms that permit, the user to\n   recombine or relink the Application with a modified version of\n   the Linked Version to produce a modified Combined Work, in the\n   manner specified by section 6 of the GNU GPL for conveying\n   Corresponding Source.\n\n   1) Use a suitable shared library mechanism for linking with the\n   Library.  A suitable mechanism is one that (a) uses at run time\n   a copy of the Library already present on the user's computer\n   system, and (b) will operate properly with a modified version\n   of the Library that is interface-compatible with the Linked\n   Version.\n</code></pre> <p>e) Provide Installation Information, but only if you would otherwise    be required to provide such information under section 6 of the    GNU GPL, and only to the extent that such information is    necessary to install and execute a modified version of the    Combined Work produced by recombining or relinking the    Application with a modified version of the Linked Version. (If    you use option 4d0, the Installation Information must accompany    the Minimal Corresponding Source and Corresponding Application    Code. If you use option 4d1, you must provide the Installation    Information in the manner specified by section 6 of the GNU GPL    for conveying Corresponding Source.)</p> <ol> <li>Combined Libraries.</li> </ol> <p>You may place library facilities that are a work based on the Library side by side in a single library together with other library facilities that are not Applications and are not covered by this License, and convey such a combined library under terms of your choice, if you do both of the following:</p> <p>a) Accompany the combined library with a copy of the same work based    on the Library, uncombined with any other library facilities,    conveyed under the terms of this License.</p> <p>b) Give prominent notice with the combined library that part of it    is a work based on the Library, and explaining where to find the    accompanying uncombined form of the same work.</p> <ol> <li>Revised Versions of the GNU Lesser General Public License.</li> </ol> <p>The Free Software Foundation may publish revised and/or new versions of the GNU Lesser General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.</p> <p>Each version is given a distinguishing version number. If the Library as you received it specifies that a certain numbered version of the GNU Lesser General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that published version or of any later version published by the Free Software Foundation. If the Library as you received it does not specify a version number of the GNU Lesser General Public License, you may choose any version of the GNU Lesser General Public License ever published by the Free Software Foundation.</p> <p>If the Library as you received it specifies that a proxy can decide whether future versions of the GNU Lesser General Public License shall apply, that proxy's public statement of acceptance of any version is permanent authorization for you to choose that version for the Library.</p>"},{"location":"about/VERSION/","title":"VERSION.md","text":"<p>Version 1.1 (July 2022)</p>"},{"location":"about/publications/","title":"Publications","text":"<p>A selection of papers using the Quantum KITE code for real-space simulations of condensed matter:</p> <ul> <li> <p>Instability of quadratic band crossing systems to topological Anderson insulating phases,   N Sobrosa, M Gon\u00e7alves and E V Castro, Phys. Rev. B 109, 184206 (2024)</p> </li> <li> <p>Genuine topological Anderson insulator from impurity induced chirality reversal,   A Neehus, F Pollmann and J Knolle, arXiv:2405.19289</p> </li> <li> <p>Electronic and magnetotransport properties of twisted bilayer graphene in the presence of external electric and magnetic fields,   P Sinha, A Mondal, S M Jo\u00e3o, and B L Chittari, Phys. Rev. B 109, 155412 (2024)</p> </li> <li> <p>Fast Fourier-Chebyshev Approach to Real-Space Simulations of the Kubo Formula,   S G de Castro, J M V P Lopes, A Ferreira and D A Bahamon, Phys. Rev. Lett. 132, 076302 (2024)</p> </li> <li> <p>Anomalous Transport Signatures in Weyl Semimetals with Point Defects,   J P Santos Pires, S M Jo\u00e3o, A Ferreira, B Amorim, and J M V P Lopes, Phys. Rev. Lett. 129, 196601 (2022)</p> </li> <li> <p>Nodal vacancy bound states and resonances in three-dimensional Weyl semimetals,   J P Santos Pires, S M Jo\u00e3o, A Ferreira, B Amorim, and J M V P Lopes, Phys. Rev. B 106, 184201 (2022)</p> </li> <li> <p>High-resolution real-space evaluation of the self-energy operator of disordered lattices: Gade singularity, spin\u2013orbit effects and p-wave superconductivity,   S M Jo\u00e3o, J M V P Lopes and A Ferreira, J. Phys. Mater. 5 045002 (2022)</p> </li> <li> <p>Decoding the DC and optical conductivities of disordered MoS2 films: an inverse problem,   F R Duarte, S Mukim, A Molina-S\u00e1nchez, T G Rappoport and M S Ferreira, New J. Phys. 23 073035 (2021)</p> </li> <li> <p>Disorder-Driven Multifractality Transition in Weyl Nodal Loops,   M Gon\u00e7alves, P Ribeiro, E V. Castro, and M A Ara\u00fajo, Phys. Rev. Lett. 124, 136405 (2020)</p> </li> <li> <p>Breakdown of universality in three-dimensional Dirac semimetals with random impurities,   J P S Pires, B. Amorim, A Ferreira, I Adagideli, E R. Mucciolo, and J M V P Lopes, Phys. Rev. Research 3, 013183 (2020) </p> </li> </ul>"},{"location":"api/","title":"Overview","text":"<p>Info</p> <p>If you just started working with KITE, look at the installation instructions and the tutorial first.</p> <p>This section describes all the classes, functions and commands for the KITE library. This reference is split-up in the different sub-programs:</p> <ul> <li>The KITE python package (for pre-processing)</li> <li>The KITEx executable (for doing the calculation)</li> <li>The KITE-tools executable (for post-processing)</li> </ul>"},{"location":"api/kite-tools/","title":"Toolbox","text":""},{"location":"api/kite-tools/#usage","title":"Usage","text":""},{"location":"api/kite-tools/#default-usage","title":"Default usage","text":"<p>Its default usage is very simple:</p> <pre><code>./build/KITE-tools archive.h5\n</code></pre> <p>where archive.h5 is the HDF file that stores the output of KITE. If KITE-tools does not find this output, it will return an error. The output of KITE-tools is a set of .dat files, one for each of the requested quantities. KITE-tools may be executed without any additional parameters; all the unspecified parameters required for the calculation will be set to sensible default values. At the moment, KITE-tools is able to compute the following quantities:</p> <ul> <li>Local density of states (LDOS)</li> <li>Angle-resolved photoemission spectroscopy (experimental) (ARPES)</li> <li>Density of states (DOS)</li> <li>DC conductivity (CondDC)</li> <li>Optical conductivity (CondOpt)</li> <li>Second-order optical conductivity (CondOpt2)</li> </ul> <p>The SingleShot DC conductivity does not require the post-processing through KITE-tools.</p>"},{"location":"api/kite-tools/#advanced-usage","title":"Advanced usage","text":"<p>KITE-tools supports a set of command-line instructions to force it to use user-specified parameters for each of the quantities mentioned in the previous section. The syntax is as following:</p> <pre><code>./build/KITE-tools archive.h5 --quantity_to_compute1 -key_1 value_1 -key_2 value_2 --quantity_to_compute2 -key_3 value_3 ...\n</code></pre> <p>Each function to compute is specified after the double hyphens \u2014 and the parameters of each function is specified after the single hyphen -. The list of available commands is as follows:</p> Function Parameter Description <code>--LDOS</code> <code>-N</code> Name of the output file <code>--LDOS</code> <code>-M</code> Number of Chebyshev moments <code>--LDOS</code> <code>-K</code> Kernel to use (jackson/green). green requires broadening parameter. Example: <code>-K green 0.01</code> <code>--LDOS</code> <code>-X</code> Exclusive. Only calculate this quantity <code>--ARPES</code> <code>-N</code> Name of the output file <code>--ARPES</code> <code>-E</code> min max num Number of energy points <code>--ARPES</code> <code>-F</code> Fermi energy <code>--ARPES</code> <code>-T</code> Temperature <code>--ARPES</code> <code>-V</code> Wave vector of the incident wave <code>--ARPES</code> <code>-O</code> Frequency of the incident wave <code>--ARPES</code> <code>-X</code> Exclusive. Only calculate this quantity <code>--DOS</code> <code>-N</code> Name of the output file <code>--DOS</code> <code>-E</code> Number of energy points <code>--DOS</code> <code>-M</code> Number of Chebyshev moments <code>--DOS</code> <code>-K</code> Kernel to use (jackson/green). green requires broadening parameter. Example: <code>-K green 0.01</code> <code>--DOS</code> <code>-X</code> Exclusive. Only calculate this quantity <code>--CondDC</code> <code>-N</code> Name of the output file <code>--CondDC</code> <code>-E</code> Number of energy points used in the integration <code>--CondDC</code> <code>-M</code> Number of Chebyshev moments <code>--CondDC</code> <code>-T</code> Temperature <code>--CondDC</code> <code>-S</code> Broadening parameter of the Green\u2019s function <code>--CondDC</code> <code>-d</code> Broadening parameter of the Dirac delta <code>--CondDC</code> <code>-F</code> min max numRange of Fermi energies. min and max may be omitted if only one is required <code>--CondDC</code> <code>-t</code> Number of threads <code>--CondDC</code> <code>-I</code> If <code>0</code>, CondDC uses the DOS to estimate the integration range <code>--CondDC</code> <code>-X</code> Exclusive. Only calculate this quantity <code>--CondOpt</code> <code>-N</code> Name of the output file <code>--CondOpt</code> <code>-E</code> Number of energy points used in the integration <code>--CondOpt</code> <code>-M</code> Number of Chebyshev moments <code>--CondOpt</code> <code>-T</code> Temperature <code>--CondOpt</code> <code>-F</code> Fermi energy <code>--CondOpt</code> <code>-S</code> Broadening parameter of the Green\u2019s function <code>--CondOpt</code> <code>-O</code> min max num Range of frequencies <code>--CondOpt2</code> <code>-N</code> Name of the output file <code>--CondOpt2</code> <code>-E</code> Number of energy points used in the integration <code>--CondOpt2</code> <code>-M</code> Number of Chebyshev moments <code>--CondOpt2</code> <code>-R</code> Ratio of the second frequency relative to the first one <code>--CondOpt2</code> <code>-P</code> If set to 1: writes all the different contributions to separate files <code>--CondOpt2</code> <code>-T</code> Temperature <code>--CondOpt2</code> <code>-F</code> Fermi energy <code>--CondOpt2</code> <code>-S</code> Broadening parameter of the Green\u2019s function <code>--CondOpt2</code> <code>-O</code> min max num Range of frequencies <p>All the values specified in this way are assumed to be in the same units as the ones used in the configuration file. All quantities are double-precision numbers except for the ones representing integers, such as the number of points. This list may be found in KITE-tools, run <code>KITE-tools --help</code>:</p>"},{"location":"api/kite-tools/#output","title":"Output","text":"<p>In the table below, we specify the name of the files that are created by KITE-tools according to the calculated quantity and the format of the data file.</p> Quantity File Column 1 Column 2 Column 3 Local Density of States <code>ldos{E}.dat</code> lattice position LDOS (\\(Re\\)) ARPES <code>arpes.dat</code> k-vector ARPES (\\(Re\\)) Density of States <code>dos.dat</code> energy DOS (\\(Re\\)) DOS (\\(Im\\)) Optical Conductivity <code>optical_cond.dat</code> Frequency Opt. Cond (\\(Re\\)) Opt. Cond (\\(Im\\)) DC Conductivity <code>condDC.dat</code> Fermi energy Cond (\\(Re\\)) Cond (\\(Im\\)) Second-order optical conductivity <code>nonlinear_cond.dat</code> Frequency NL Cond (\\(Re\\)) NL Cond (\\(Im\\)) Single-shot DC Conductivity <code>[HDF5-filename].dat</code> Fermi energy Cond (\\(Re\\)) Cond (\\(Im\\)) <ul> <li>All linear conductivities are in units of \\(e^2/h\\)</li> <li>Both Planck\u2019s constant and electron charge are set to 1.</li> <li>LDOS outputs one file for each requested energy. The energy is in the E in the file name.</li> </ul> <p>For more details on the type of calculations performed during post-processing, check Resources where we discuss our method.</p> <p>Processing the single-shot DC conductivity</p> <p>The single shot DC conductivity does not need any post-processing as it is an energy dependent calculation where the conductivity is calculated on the fly. In this particular case, the data is extracted directly from the hdf file with the following python script in the <code>kite/tools/</code>-folder:</p> <pre><code>python3 process_single_shot.py output.h5\n</code></pre> <p>The output of this script will be a data-file with name <code>output.dat</code> or similar, structured as given in the table above.</p>"},{"location":"api/kite-tools/#examples","title":"Examples","text":""},{"location":"api/kite-tools/#example-1","title":"Example 1","text":"<pre><code>./KITE-tools h5_file.h5 --DOS -E 1024\n</code></pre> <p>Processes the .h5 file as usual but ignores the number of energy points in the density of states present there. Instead, KITE-tools will use the value 1024 as specified in the example.</p>"},{"location":"api/kite-tools/#example-2","title":"Example 2","text":"<pre><code>./KITE-tools h5_file.h5 --CondDC -E 552 -S 0.01\n</code></pre> <p>Processes the .h5 file but uses 552 points for the energy integration and a broadening parameter of 0.01.</p>"},{"location":"api/kite-tools/#example-3","title":"Example 3","text":"<pre><code>./KITE-tools h5_file.h5 --CondDC -T 0.4 -F 500\n</code></pre> <p>Calculates the DC conductivity using a temperature of 0.4 and 500 equidistant Fermi energies spanning the spectrum of the Hamiltonian.</p>"},{"location":"api/kite-tools/#example-4","title":"Example 4","text":"<pre><code>./KITE-tools h5_file.h --CondDC -F -1.2 2.5 30 --CondOpt -T 93\n</code></pre> <p>Calculates the DC conductivity using 30 equidistant Fermi energies in the range <code>[-1.2, 2.5]</code> and the optical conductivity using a temperature of 93.</p> <p>@@includekite_tools_readme.md</p>"},{"location":"api/kite/","title":"Python package","text":"<p>The KITE package for pre-processing is split up in various subclasses and contains several functions:</p> <ul> <li>class <code>kite.StructuralDisorder(lattice, concentration=0, position=None)</code> - Add disorder to the lattice.</li> <li>class <code>kite.Disorder(lattice)</code> - Add Guassian disorder to the lattice.</li> <li>class <code>kite.Modification(magnetic_field=None, flux=None)</code> - Add a magnetic field to the lattice.</li> <li>class <code>kite.Configuration([...])</code> - Define the basic parameters used in the calculation.</li> <li>class <code>kite.Calculation(configuration=None)</code> - Describe the required target functions.</li> <li>function make_pybinding_model</li> <li>function estimate_bounds</li> <li>function config_system</li> <li>warning LoudDeprecationWarning</li> </ul>"},{"location":"api/kite/#structuraldisorder","title":"StructuralDisorder","text":"<p>class <code>kite.StructuralDisorder(lattice, concentration=0, position=None)</code></p> Class that introduces Structural Disorder into the initially built <code>pb.Lattice</code>. Parameters <code>lattice</code>: <code>pb.Lattice</code> The lattice used to build the structural disorder. <code>concentration</code>: <code>float</code> Concentration of disorder (can only be different from <code>0</code> if <code>position=None</code>). <code>position</code>: <code>array_like</code> Exact position of disorder (can only be different from <code>None</code> if <code>concentration=0</code>). Methods Method Description <code>add_vacancy(*disorder)</code> Add vacancy disorder to the lattice. <code>add_structural_disorder(*disorder)</code> Add structural disorder to the lattice. <code>add_local_vacancy_disorder(relative_index, sub)</code> Internal function to add one vacancy disorder to chosen position. <code>add_local_bond_disorder(relative_index_from, [, ...])</code> Internal function to add one bond disorder between chosen positions. <code>add_local_onsite_disorder(relative_index, [, ...])</code> Internal function to add one onsite disorder to chosen position. <code>map_the_orbital(orb, nodes_map)</code> Internal function to map the orbitals to the NodesMap. <p>function <code>add_vacancy(*disorder)</code> <p>Add vacancy disorder to the lattice.</p> Parameters Parameter Description <code>*disorder</code>:<code>str</code> or <code>tuple(array_like, str)</code> Vacancy disorder, in the form of <code>sublattice_name</code> or <code>([relatice_index], sublattice_name)</code> <p>function<code>add_structural_disorder(*disorder)</code></p> <p>Add structural disorder to the lattice.</p> Parameters Parameter Description <code>*disorder</code>:<code>tuple(array_like, str, float)</code> or <code>tuple(array_like, str, array_like, str, array_like)</code> or <code>tuple(array_like, str, array_like, str, float)</code> or <code>tuple(array_like, str, array_like)</code> Vacancy disorder, in the form of <code>([relatice_index], sublattice_name, onsite_energy)</code> or <code>([relatice_index_from], sublattice_name_from, [relatice_index_to], sublattice_name_to, onsite_energy)</code> <p>function<code>add_local_vacancy_disorder(relative_index, sub)</code></p> <p>Internal function to add one vacancy disorder to chosen position.</p> Parameters Parameter Description <code>relative_index</code>:<code>array_like</code> Relative index of the position to change the onsite energy. <code>sub</code>:<code>str</code> Name of the sublattice to change the onsite energy. <p>function <code>add_local_bond_disorder(relative_index_from, from_sub, relative_index_to, to_sub, hoppings)</code></p> <p>Internal function to add one bond disorder between chosen positions.</p> Parameters Parameter Description <code>relative_index_from</code>:<code>array_like</code> Relative index of the position from wich the bond connects to change the onsite energy. <code>from_sub</code>:<code>str</code> Name of the sublattice from wich the bond connects to change the onsite energy. <code>relative_index_to</code>:<code>array_like</code> Relative index of the position to wich the bond connects to change the onsite energy. <code>to_sub</code>:<code>str</code> Name of the sublattice to wich the bond connects to change the onsite energy. <code>hoppings</code>:<code>float</code> or <code>array_like</code> The hopping energy between the different sublattices at the given positions, with the right shape to connect between the orbitals. <p>function <code>add_local_onsite_disorder(relative_index, sub, value)</code></p> <p>AInternal function to add one onsite disorder to chosen position.</p> Parameters Parameter Description <code>relative_index</code>:<code>array_like</code> Relative index of the position to change the onsite energy. <code>sub</code>:<code>str</code> Name of the sublattice to change the onsite energy. <code>value</code>:<code>float</code> or <code>array_like</code> The onsite energy of sublattice at the given positions, with the right shape for the orbitals. <p>function <code>map_the_orbital(orb, nodes_map)</code></p> <p>Internal function to map the orbitals to the NodesMap.</p> Parameters Parameter Description <code>orb</code>:<code>str</code> Name of the sublattice to give a unique value. <code>nodes_map</code>:<code>dict</code> The object that stores the unique values for the sublattices."},{"location":"api/kite/#disorder","title":"Disorder","text":"<p>class <code>kite.Disorder(lattice)</code></p> <p>Class that introduces Disorder into the initially built <code>pb.Lattice</code>.</p> <p>The informations about the disorder are the type, mean value, and standard deviation. The function that you can use in the bulding of the <code>pb.Lattice</code> is <code>add_disorder()</code>. The class method takes care of the shape of the disorder chosen (it needs to be same as the number of orbitals at a given atom), and takes care of the conversion to the c++ orbital-only format.</p> Parameters <code>lattice</code>: <code>pb.Lattice</code> The lattice used to build the disorder. Methods Method Description <code>add_disorder(sublattice [, ...])</code> Add the disorder to the lattice. <code>add_local_disorder(sublattice_name [, ...])</code> Internal function to add the disorder to the positions. <p>function <code>add_disorder(sublattice, dis_type, mean_value, standard_deviation=0.)</code></p> <p>Add the disorder to the lattice.</p> Parameters Parameter Description <code>sublattice</code>:<code>str</code> or <code>list(str)</code> Name of the sublattice to give a unique value. <code>dis_type</code>:<code>int</code> or <code>list(int)</code> The type of disorder to apply, possible values are <code>\"Gaussian\"</code>, <code>\"Uniform\"</code>, <code>\"Deterministic\"</code>,  <code>\"gaussian\"</code>,  <code>\"uniform\"</code> or <code>\"deterministic\"</code>. <code>dis_mean_valuetype</code>:<code>float</code> or <code>list(float)</code> Mean value of the deformation. <code>standard_deviation</code>:<code>float</code> or <code>list(float)</code> Standard deviation of the deformation. <p>function<code>add_local_disorder(sublattice_name, dis_type, mean_value, standard_deviation)</code></p> <p>Internal function to add the disorder to the positions.</p> Parameters Parameter Description <code>sublattice</code>:<code>list(str)</code> Name of the sublattices to give a unique value. <code>dis_type</code>:<code>list(int)</code> The type of disorder to apply, possible values are <code>\"Gaussian\"</code>, <code>\"Uniform\"</code>, <code>\"Deterministic\"</code>,  <code>\"gaussian\"</code>,  <code>\"uniform\"</code> or <code>\"deterministic\"</code>. <code>dis_mean_valuetype</code>:<code>list(float)</code> Mean value of the deformation. <code>standard_deviation</code>:<code>list(float)</code> Standard deviation of the deformation."},{"location":"api/kite/#modification","title":"Modification","text":"<p>class <code>kite.Modification(magnetic_field=None, flux=None)</code></p> Class that modifies the initially built <code>pb.Lattice</code> with a magnetic field. Parameters <code>magnetic_field</code>: <code>float</code> Add the magnetic field to the lattice. The field will point along the second primitive lattice vector of the lattice. The magnetic field is in units of \\(Tesla\\), if the <code>pb.Lattice</code> is in units of \\(nm\\). The magnetic field is rounded down to the nearest flux quantum. <code>flux</code>: <code>float</code> Add the magnetic flux to the lattice. Attributes Attribute Description <code>magnetic_field</code>:<code>float</code> The added magnetic field to the lattice. <code>flux</code>:<code>float</code> The added magnetic flux to the lattice. This is not* the exact value used in the calculation, but the value added using the parameter above."},{"location":"api/kite/#configuration","title":"Configuration","text":"<p>class <code>kite.Configuration(divisions=(1, 1, 1), length=(1, 1, 1), boundaries=('open', 'open', 'open'), is_complex=False, precision=1, spectrum_range=None, angles=(0,0,0), custom_local=False, custom_local_print=False)</code></p> Define the basic parameters used in the calculation Parameters <code>divisions</code>: <code>int</code> or <code>tuple(int, int)</code> or <code>tuple(int, int, int)</code> Number of decomposition parts of the system. <code>length</code>: <code>int</code> or <code>tuple(int, int)</code> or <code>tuple(int, int, int)</code> Number of unit cells in each direction. <code>boundaries</code>: <code>str</code> or <code>tuple(str, str)</code> or <code>tuple(str, str, str)</code> Periodic boundary conditions each direction. Possible values are <code>\"periodic\"</code>, <code>\"open\"</code>,   <code>\"twisted\"</code>*(this option needs the extra argument <code>angles</code> and <code>\"random\"</code> <code>is_complex</code>: <code>bool</code> Boolean that reflects whether the type of Hamiltonian is complex or not. <code>precision</code>: <code>int</code> Integer which defines the precision of the number used in the calculation,   <code>float</code> (<code>0</code>), <code>double</code> (<code>1</code>), <code>long double</code> (<code>2</code>). <code>spectrum_range</code>: <code>tuple(float, float)</code> <p>Energy scale which defines the scaling factor of all the energy related parameters.   The scaling is done automatically in the background after this definition.   If the term is not specified, a rough estimate of the bounds is found.</p> <p>Warning</p> <p>Automatic scaling can lead to segmentation-errors due to an error in pybinding.</p> <code>angles</code>: <code>float</code> or <code>tuple(float, float)</code> or <code>tuple(float, float, float)</code> The angles used for the twisted boundary conditions when <code>boundary=\"twist\"</code> is selected.   The values of <code>angle</code>must be in the interval \\([0, M \\cdot 2 \\pi]\\). <code>custom_local</code>: <code>bool</code> Boolean that reflects whether the calculation should use the user-defined local potential. <code>custom_local_print</code>: <code>bool</code> Boolean that reflects whether the calculation should use output the values for the local potential for the various sublattices of the <code>pb.Lattice</code>. Attributes Attribute Description <code>energy_scale</code>:<code>float</code> Returns the energy scale of the hopping parameters. <code>energy_shift</code>:<code>float</code> Returns the energy shift of the hopping parameters around which the spectrum is centered. <code>comp</code>:<code>int</code> Returns <code>0</code> if hamiltonian is real and <code>1</code> elsewise. <code>prec</code>:<code>int</code> Returns <code>0</code>, <code>1</code>, <code>2</code> if precision if <code>float</code>, <code>double</code>, and <code>long double</code> respectively. <code>div</code>:<code>int</code> Returns the number of decomposed elements of matrix in \\(x\\), \\(y\\) and/or \\(z\\) direction. Their product gives the total number of threads spawn. <code>bound</code>:<code>tuple(array_like, array_like)</code> Returns the boundary conditions in each direction, the first argument describes the boundary conditions for the various dimensions with <code>0</code> - open boundary condtions, <code>1</code> - periodic or twisted boundary conditions, <code>2</code> - random boundary conditions, the second gives the angle used if <code>boundary=\"twist\"</code> was chosen. <code>leng</code>:<code>array_like</code> Return the number of unit cell repetitions in each direction. <code>type</code>:<code>np.float32</code> or <code>np.float64</code> or <code>np.float128</code> or <code>np.float256</code> Return the type of the Hamiltonian complex or real, and float, double or long double. <code>custom_pot</code>:<code>bool</code> Return custom potential flag. <code>print_custom_pot</code>:<code>bool</code> Return print custom potential flag. Methods Method Description <code>set_type()</code> Internal function to determine the precision to be used during the calculation. <p>function <code>set_type()</code></p> Internal function to determine the precision to be used during the calculation."},{"location":"api/kite/#calculation","title":"Calculation","text":"<p>class <code>kite.Calculation(configuration=None)</code></p> Class that contains the required target functions to calculate in later steps. Parameters <code>configuration</code>: <code>kite.Configuration</code> A <code>kite.Configuration</code> that contains the settings for the calculation. Attributes Attribute Description <code>get_dos</code>:<code>dict</code> Returns the requested DOS functions. <code>get_ldos</code>:<code>dict</code> Returns the requested LDOS functions. <code>get_arpes</code>:<code>dict</code> Returns the requested ARPES functions. <code>get_gaussian_wave_packet</code>:<code>dict</code> Returns the requested wave packet time evolution function, with a gaussian wavepacket mutiplied with different plane waves. <code>get_conductivity_dc</code>:<code>dict</code> Returns the requested DC conductivity functions. <code>get_conductivity_optical</code>:<code>dict</code> Returns the requested optical conductivity functions. <code>get_conductivity_optical_nonlinear</code>:<code>dict</code> Returns the requested nonlinear optical conductivity functions. <code>get_singleshot_conductivity_dc</code>:<code>dict</code> Returns the requested singleshot DC conductivity functions. Methods Method Description <code>dos(num_points, num_moments, [, ...]</code>) Calculate the density of states as a function of energy. <code>ldos(energy, num_moments, [, ...])</code> Calculate the local density of states as a function of energy. <code>arpes(k_vector, weight [, ...])</code> Calculate the spectral contribution for given k-points and weights. <code>gaussian_wave_packet(num_points [, ...])</code> Calculate the time evolution function of a wave packet. <code>conductivity_dc(direction, [, ...])</code> Calculate the DC conductivity for a given direction. <code>conductivity_optical(direction, [, ...])</code> Calculate optical conductivity for a given direction. <code>conductivity_optical_nonlinear([...])</code> Calculate nonlinear optical conductivity for a given direction. <code>singleshot_conductivity_dc(energy, [...])</code> Calculate the DC conductivity using KITEx for a given direction and energy. <p>function <code>dos(num_points, num_moments, num_random, num_disorder=1)</code></p> <p>Calculate the density of states as a function of energy.</p> Parameters Parameter Description <code>num_points</code>:<code>int</code> Number of energy point inside the spectrum at which the DOS will be calculated. <code>num_moments</code>:<code>int</code> Number of polynomials in the Chebyshev expansion. <code>num_random</code>:<code>int</code> Number of random vectors to use for the stochastic evaluation of trace. <code>num_disorder</code>:<code>int</code> Number of different disorder realisations. <p>function<code>ldos(energy, num_moments, position, sublattice, num_disorder=1)</code></p> <p>Calculate the local density of states as a function of energy. </p> Parameters Parameter Description <code>energy</code>:<code>array_like</code> List of energy points at which the LDOS will be calculated. <code>num_moments</code>:<code>int</code> Number of polynomials in the Chebyshev expansion. <code>position</code>:<code>int</code> Relative index of the unit cell where the LDOS will be calculated. <code>sublattice</code>:<code>list</code> Name of the sublattice at which the LDOS will be calculated. <code>num_disorder</code>:<code>str</code> or <code>list</code> Number of different disorder realisations. <p>function<code>arpes(k_vector, weight, num_moments, num_disorder=1)</code></p> <p>Calculate the spectral contribution for given k-points and weights.</p> Parameters Parameter Description <code>k_vector</code>:<code>array_like</code> List of K points with respect to reciprocal vectors b0 and b1 at which the band structure will be calculated. <code>weight</code>:<code>array_like</code> List of orbital weights used for ARPES. <code>num_moments</code>:<code>int</code> Number of polynomials in the Chebyshev expansion. <code>num_disorder</code>:<code>int</code> Number of different disorder realisations. <p>function<code>gaussian_wave_packet(num_points, num_moments, timestep, k_vector, spinor, width, mean_value, num_disorder=1, probing_point=0)</code></p> <p>Calculate the time evolution function of a wave packet.</p> Parameters Parameter Description <code>num_points</code>:<code>int</code> Number of time points for the time evolution. <code>num_moments</code>:<code>int</code> Number of polynomials in the Chebyshev expansion. <code>timestep</code>:<code>float</code> Timestep for calculation of time evolution. <code>k_vector</code>:<code>array_like</code> Different wave vectors, components corresponding to vectors b0 and b1. <code>spinor</code>:<code>array_like</code> Spinors for each of the k vectors. <code>width</code>:<code>float</code> Width of the gaussian. <code>mean_value</code>:<code>tuple(float, float)</code> Mean value of the gaussian envelope. <code>num_disorder</code>:<code>int</code> Number of different disorder realisations. <code>probing_point</code>:<code>int</code> or <code>array_like</code> Forward probing point, defined with x, y coordinate were the wavepacket will be checked at different timesteps. <p>function<code>conductivity_dc(direction, num_points, num_moments, num_random, num_disorder=1, temperature=0)</code></p> <p>Calculate the DC conductivity for a given direction.</p> Parameters Parameter Description <code>direction</code>:<code>str</code> Direction in \\(xyz\\)-coordinates along which the conductivity is calculated, supports <code>\"xx\"</code>, <code>\"yy\"</code>, <code>\"zz\"</code>, <code>\"xy\"</code>, <code>\"xz\"</code>, <code>\"yx\"</code>, <code>\"yz\"</code>, <code>\"zx\"</code>, <code>\"zy\"</code>. <code>num_points</code>:<code>int</code> Number of energy point inside the spectrum at which the DOS will be calculated. <code>num_moments</code>:<code>int</code> Number of polynomials in the Chebyshev expansion. <code>num_random</code>:<code>int</code> Number of random vectors to use for the stochastic evaluation of trace. <code>num_disorder</code>:<code>int</code> Number of different disorder realisations. <code>temperature</code>:<code>float</code> Value of the temperature at which we calculate the response. If \\(eV\\) is used as unit for energy, then \\(k_B\\cdot T\\) is also in \\(eV\\). To define the temperature in arbitraty units, specify the quantity \\(K_B \\cdot T\\), which has units of energy. <p>function<code>conductivity_optical(direction, num_points, num_moments, num_random, num_disorder=1, temperature=0)</code></p> <p>Calculate optical conductivity for a given direction.</p> Parameters Parameter Description <code>direction</code>:<code>str</code> Direction in \\(xyz\\)-coordinates along which the conductivity is calculated, supports <code>\"xx\"</code>, <code>\"yy\"</code>, <code>\"zz\"</code>, <code>\"xy\"</code>, <code>\"xz\"</code>, <code>\"yx\"</code>, <code>\"yz\"</code>, <code>\"zx\"</code>, <code>\"zy\"</code>. <code>num_points</code>:<code>int</code> Number of energy point inside the spectrum at which the DOS will be calculated. <code>num_moments</code>:<code>int</code> Number of polynomials in the Chebyshev expansion. <code>num_random</code>:<code>int</code> Number of random vectors to use for the stochastic evaluation of trace. <code>num_disorder</code>:<code>int</code> Number of different disorder realisations. <code>temperature</code>:<code>float</code> Value of the temperature at which we calculate the response. If \\(eV\\) is used as unit for energy, then \\(k_B\\cdot T\\) is also in \\(eV\\). To define the temperature in arbitraty units, specify the quantity \\(K_B \\cdot T\\), which has units of energy. <p>function<code>conductivity_optical_nonlinear(direction, num_points, num_moments, num_random, num_disorder=1, temperature=0, special=0)</code></p> <p>Calculate nonlinear optical conductivity for a given direction.</p> Parameters Parameter Description <code>direction</code>:<code>str</code> Direction in \\(xyz\\)-coordinates along which the conductivity is calculated, supports all the combinations of the directions <code>\"x\"</code>, <code>\"y\"</code> and <code>\"z\"</code> with length 3 like <code>\"xxx\"</code>, <code>\"zzz\"</code>, <code>\"xxy\"</code>, <code>\"xxz\"</code> etc. <code>num_points</code>:<code>int</code> Number of energy point inside the spectrum at which the DOS will be calculated. <code>num_moments</code>:<code>int</code> Number of polynomials in the Chebyshev expansion. <code>num_random</code>:<code>int</code> Number of random vectors to use for the stochastic evaluation of trace. <code>num_disorder</code>:<code>int</code> Number of different disorder realisations. <code>temperature</code>:<code>float</code> Value of the temperature at which we calculate the response. If \\(eV\\) is used as unit for energy, then \\(k_B\\cdot T\\) is also in \\(eV\\). To define the temperature in arbitraty units, specify the quantity \\(K_B \\cdot T\\), which has units of energy. <code>special</code>:<code>int</code> Optional, a parameter that can simplify the calculation for some materials. <p>function<code>singleshot_conductivity_dc(energy, direction, eta, num_moments, num_random, num_disorder=1, preserve_disorder=False)</code></p> <p>Calculate the DC conductivity using KITEx for a given direction and energy.</p> <p>Processing the output of <code>singleshot_conductivity_dc()</code></p> <p><code>singleshot_conductivity_dc()</code> works different from the other target-functions in that a single run with KITEx is sufficient. The results don't have to be processed by KITE-tools. As such, the results are already available in the HDF5-file. You can extract the results from the HDF5-file as explained in the tutorial.</p> <p>There is also a script that automates this process with, <code>\"output.h5\"</code> the name of the HDF5-file processed by KITEx:</p> <pre><code>python3 process_single_shot.py output.h5\n</code></pre> <p>this will result in a data-file <code>\"output.dat\"</code>, as explained in the API of KITE-tools.                </p> Parameters Parameter Description <code>energy</code>:<code>array_like</code> or <code>float</code> Array or a single value of energies at which <code>singleshot_conductivity_dc</code> will be calculated. <code>direction</code>:<code>str</code> Direction in \\(xyz\\)-coordinates along which the conductivity is calculated, supports <code>\"xx\"</code>, <code>\"yy\"</code> and <code>\"zz\"</code>. <code>eta</code>:<code>int</code> Parameter that affects the broadening of the kernel function. <code>num_moments</code>:<code>int</code> Number of polynomials in the Chebyshev expansion. <code>num_random</code>:<code>int</code> Number of random vectors to use for the stochastic evaluation of trace. <code>num_disorder</code>:<code>int</code> Number of different disorder realisations. <code>preserve_disorder</code>:<code>bool</code> Optional."},{"location":"api/kite/#make_pybinding_model","title":"make_pybinding_model","text":"<p>function <code>kite.make_pybinding_model(lattice, disorder=None, disorder_structural=None, shape=None)</code></p> <p>Build a Pybinding model with disorder used in Kite. Bond disorder or magnetic field are not currently supported.</p> Parameters Parameter Description <code>lattice</code>:<code>pb.Lattice</code> Pybinding lattice object that carries the info about the unit cell vectors, unit cell cites, hopping terms and onsite energies. <code>disorder</code>:<code>kite.Disorder</code> Class that introduces <code>kite.Disorder</code> into the initially built lattice. For more info check the <code>kite.Disorder</code> class. <code>disorder_structural</code>:<code>kite.StructuralDisorder</code> Class that introduces <code>kite.StructuralDisorder</code> into the initially built lattice. For more info check the <code>kite.StructuralDisorder</code> class. <code>shape</code>:<code>pb.Shape</code> Optional argument <code>pb.Shape</code>."},{"location":"api/kite/#estimate_bounds","title":"estimate_bounds","text":"<p>function <code>kite.estimate_bounds(lattice, disorder=None, disorder_structural=None)</code></p> <p>Estimate the bounds for the energy, given the <code>pb.Lattice</code> and/or <code>kite.Disorder</code> and/or <code>kite.StructuralDisorder</code>.</p> Parameters Parameter Description <code>lattice</code>:<code>pb.Lattice</code> Pybinding lattice object that carries the info about the unit cell vectors, unit cell cites, hopping terms and onsite energies. <code>disorder</code>:<code>kite.Disorder</code> Class that introduces <code>kite.Disorder</code> into the initially built lattice. For more info check the <code>kite.Disorder</code> class. <code>disorder_structural</code>:<code>kite.StructuralDisorder</code> Class that introduces <code>kite.StructuralDisorder</code> into the initially built lattice. For more info check the <code>kite.StructuralDisorder</code> class."},{"location":"api/kite/#config_system","title":"config_system","text":"<p>function <code>kite.config_system(lattice, config, calculation, modification=None, filename=\"kite_config.h5\", disorder=None, disorder_structural=None)</code></p> <p>Export the lattice and related parameters to the *.h5 file.</p> Parameters Parameter Description <code>lattice</code>:<code>pb.Lattice</code> Pybinding lattice object that carries the info about the unit cell vectors, unit cell cites, hopping terms and onsite energies. <code>config</code>:<code>kite.Configuration</code> <code>kite.Configuration</code> object, basic parameters defining size, precision, energy scale and number of decomposition parts in the calculation. <code>calculation</code>:<code>kite.Calculation</code> <code>kite.Calculation</code> object that defines the requested functions for the calculation. <code>modification</code>:<code>kite.Modification</code> If specified <code>kite.Modification</code> object, has the magnetic field selection, either in terms of field, or in the number of flux quantum through the selected system. <code>filename</code>: <code>str</code> Filename for the output HDF5-file. <code>disorder</code>:<code>kite.Disorder</code> Class that introduces <code>kite.Disorder</code> into the initially built lattice. For more info check the <code>kite.Disorder</code> class. <code>disorder_structural</code>:<code>kite.StructuralDisorder</code> Class that introduces <code>kite.StructuralDisorder</code> into the initially built lattice. For more info check the <code>kite.StructuralDisorder</code> class."},{"location":"api/kite/#louddeprecationwarning","title":"LoudDeprecationWarning","text":"Deprecationwarning."},{"location":"api/kite_tools_readme/","title":"Addtitional scripts","text":"<p>Info</p> <p>This file describes the contents of the <code>kite/tools</code>-folder. Note that the main post-processing tool is located in the <code>kite/build</code>-folder.</p>"},{"location":"api/kite_tools_readme/#kitetools-folder","title":"<code>kite/tools</code>-folder","text":"<p>This folder contains bespoke tools:</p>"},{"location":"api/kite_tools_readme/#1-process_arpespy","title":"1. <code>process_arpes.py</code>","text":"<p>to process the output of a spectral function calculation.</p>"},{"location":"api/kite_tools_readme/#2-process_single_shotpy","title":"2. <code>process_single_shot.py</code>","text":"<p>to extract the output data from a single-shot calculation of the longitudinal DC-conductivity. This tool is a simple python script that outputs a data file that contains three columns of data that are read out of the processed HDF5, namely:</p> Column 1 Column 2 Column 3 Fermi Energies Real Part of the Conductivity Imaginary Part of the Conductivity"},{"location":"api/kitex/","title":"Main program","text":""},{"location":"api/kitex/#usage","title":"Usage","text":"<p>Its default usage is very simple:</p> <pre><code>    ./KITEx archive.h5\n</code></pre> <p>The program only accepts and HDF5-file as input. No other command can be given to it.</p>"},{"location":"background/","title":"Overview of KITE","text":"<p>KITE is a user-friendly open source software suite for simulating electronic structure and quantum transport properties of large-scale molecular and condensed systems with up to tens of billions of atomic orbitals (\\(N\\sim 10^{10}\\)).  In a nutshell, KITE takes real-space tight-binding models of arbitrary complexity as an input that can be promptly defined by the user through its versatile Python interface.  Then, its memory-efficient and heavily-parallelized C++ code employs extremely accurate Chebyshev spectral expansions<sup>1</sup> in order to study equilibrium electronic properties (DOS, LDOS and spectral functions), response functions (linear and nonlinear conductivities) and even dynamical effects arising from the time-evolution of electronic wave-packets. The scope of KITE extends beyond periodic systems, with its true power revealed through the study of more realistic lattice models. These systems include randomly distributed dilute impurities, structural defects, ad-atoms, mechanical strain and external magnetic fields. Some illustrative examples may be found in KITE\u2019s presentation paper<sup>2</sup>. See the Tutorial section for a quick-start guide.</p> <p>KITE's latest release (version 1.1) contains the following functionalities:</p> <ul> <li>Average density of states (DOS) and local DOS</li> <li>\\(\\mathbf{k}\\)-space spectral functions and ARPES response</li> <li>Linear DC conductivity tensor (using the Kubo-Greenwood formula)</li> <li>First and second-order optical (AC) conductivities</li> <li>Spin dynamics by time-evolution of gaussian wave-packets</li> </ul> <p>These calculations can now be applied to arbitrary two- and three-dimensional tight-binding models that have:</p> <ul> <li>Generic multi-orbital local (on-site) and bond disorder</li> <li>User-defined local potential profile and structural disorder</li> <li>Different boundary conditions (periodic, open and twisted)</li> <li>Applied perpendicular magnetic field (limited use in 3D)</li> </ul> <p>Refer to the About section for more information about the current release.</p>"},{"location":"background/#a-short-background-story","title":"A Short Background Story","text":"<p>The seeds for KITE\u2019s project were planted in 2014, when an exact spectral expansion of the broadened lattice Green's function was discovered by Aires Ferreira (University of York, UK) in collaboration with Eduardo R. Mucciolo (University of Central Florida)<sup>3</sup> and, independently, by A. Braun and P. Schmitteckert (Karlsruhe Institute of Technology)<sup>4</sup>.  Aires Ferreira then developed a large-RAM \"single-shot\" recursive algorithm that enabled for the first time the study of huge tight-binding systems containing billions of atomic orbitals entirely in real space (previous approaches had been limited to a few million atoms).  At the time, this method proved essential to numerically demonstrate that zero-energy modes in graphene with dilute vacancy defects benefit from a finite (non-zero) conductivity  in the large system limit, thereby overcoming Anderson localization <sup>3</sup>.</p> <p>In the following years, the utility of real-space spectral methods<sup>5</sup> has been extended to studies of the linear conductivity tensor at finite temperature/frequency<sup>6</sup> <sup>7</sup> (proposed by L. Covaci and T. G. Rappoport in collaboration with Jos\u00e9 H. Garc\u00eda (ICN2)) and the non-linear optical response (proposed by S. M. Jo\u00e3o and J. M. Viana Parente Lopes<sup>8</sup>). It was the conjunction of all these proposals that resulted in the joint venture that led to the pre-release of KITE in 2018  and its official release (v1.0) in 2020 <sup>2</sup>.</p> <p>From its inception, KITE was built to handle real-space models of realistic complexity and sizes. Thereby, its architecture allies a versatile and user-friendly \\(\\texttt{Python}\\) interface, with an efficient \\(\\texttt{C++}\\) code (developed by J. M. Viana Parente Lopes) that handles the heavy spectral computations. The interface is based on Pybinding\u2019s syntax<sup>9</sup> which allows the user to input an arbitrary (2D or 3D) lattice model decorated with a myriad of non-periodic perturbations, such as on-site disorder, personalized structural defects, and strain.  The model Hamiltonian is then passed to the \\(\\texttt{C++}\\) code (\\(\\texttt{KITEx}\\)) which implements a matrix-free Chebyshev iteration. It combines a domain-decomposition of the lattice with a \"tile-by-tile\" matrix-vector multiplication strategy in order to minimize memory-transfer overheads and thus boost the parallelization and calculational efficiency<sup>2</sup>.  Such an approach has enabled unprecedented large-scale studies of electronic structure and non-equilibrium phenomena in a variety of systems, including disordered semi-metals, topological insulators, and superconductors, among others <sup>10</sup> <sup>11</sup>.  Finally, a convenient post-processing tool (\\(\\texttt{KITE-tools}\\)), developed by S. M. Jo\u00e3o, was also included in the package, thereby turning KITE into an all-round, ready-to-use tool for practical applications.</p> <ol> <li> <p>Kernel polynomial method, A. Wei\u00dfe, G. Wellein, A. Alvermann and H. Fehske, Rev. Mod. Phys. 78, 275 (2016) \u21a9</p> </li> <li> <p>KITE: high-performance accurate modelling of electronic structure and response functions of large molecules, disordered crystals and heterostructures, S. M. Jo\u00e3o, M. An\u0111elkovi\u0107, L. Covaci, T. G. Rappoport, Jo\u00e3o M. Viana Parente Lopes, and A. Ferreira, R. Soc. open sci. 7, 191809 (2020) \u21a9\u21a9\u21a9</p> </li> <li> <p>Critical delocalization of chiral zero energy modes in graphene, A. Ferreira and E. Mucciolo, Phys. Rev. Lett. 115, 106601 (2015) \u21a9\u21a9</p> </li> <li> <p>Numerical evaluation of Green's functions based on the Chebyshev expansion, A. Braun and P. Schmitteckert, Phys. Rev. B 90, 165112 (2014) \u21a9</p> </li> <li> <p>Efficient multiscale lattice simulations of strained and disordered graphene, N. Leconte, A. Ferreira, and J. Jung. Semiconductors and Semimetals 95, 35 (2016) \u21a9</p> </li> <li> <p>Real-space calculation of the conductivity tensor for disordered topological matter, J. H. Garc\u00eda, L. Covaci, and T. G. Rappoport, Phys. Rev. Lett. 114, 116602 (2015) \u21a9</p> </li> <li> <p>Numerical calculation of the Casimir-Polder interaction between a graphene sheet with vacancies and an atom, T. P. Cysne, T. G. Rappoport, A.Ferreira, J. M. Viana Parente Lopes, and N. M. R. Peres, Phys. Rev. B 94, 235405 (2016) \u21a9</p> </li> <li> <p>Basis-independent spectral methods for non-linear optical response in arbitrary tight-binding models, S. M. Jo\u00e3o and J. M. Viana Parente Lopes, J. Phys.: Condens. Mat. 32 (12), 125901 (2019) \u21a9</p> </li> <li> <p>Pybinding V0.9.4: a python package for tight-binding calculations, D. Moldovan, M. An\u0111elkovi\u0107, and F. M. Peeters, Zenodo (2017).\u00a0\u21a9</p> </li> <li> <p>High-resolution real-space evaluation of the self-energy operator of disordered lattices: Gade singularity, spin\u2013orbit effects and p-wave superconductivity, S. M. Jo\u00e3o, J. M. Viana Parente Lopes, and A. Ferreira, J. Phys. Mater. 5 045002 (2022) \u21a9</p> </li> <li> <p>Anomalous Transport Signatures in Weyl Semimetals with Point Defects, J. P. Santos Pires, S. M. Jo\u00e3o, A. Ferreira, B. Amorim, and J. M. Viana Parente Lopes, Phys. Rev. Lett. 129, 196601 (2022) \u21a9</p> </li> </ol>"},{"location":"background/spectral/","title":"Spectral Methods","text":"<p>The physical properties of condensed matter systems are encoded in the eigenvalues and eigenfunctions of Hamiltonian matrices \\(\\hat{H}\\) with typically very large dimension \\(D\\).  These systems are thus challenging to investigate using exact diagonalization (due to the exponential scaling of computer resources with the system size),  but a wide range of many-body methods and approximations are available that can help us to understand particular aspects of certain systems and even predict new phenomena. In particular, spectral methods have recently become popular  for enabling the reconstruction of key physical quantities and observables in an unbiased, numerically exact fashion at a fraction of the computational cost of exact diagonalization methods. In the spectral approach, the quantity of interest (target function) is decomposed into a spectral series</p> <p> \\[     f(x) \\propto \\sum\\limits_{n=0}^\\infty f_n P_n(x),\\quad\\quad   (1) \\label{eq:1} \\] <p></p> <p>where \\(P_n(x)\\) are orthogonal polynomials (basis functions) and \\(x\\) is the argument, such as the Fermi energy or frequency. The elegance and power of spectral decompositions such as Eq. \\((1)\\) lie in the fact that the expansion moments \\(f_n\\) can be obtained by means of a highly-efficient and stable recursive scheme. Once these moments are determined (to some desired precision), the target function \\(f(x)\\) can be easily and quickly reconstructed over the desired range of \\(x\\). </p> <p>For example, consider the Chebyshev polynomials of the first kind:</p> <p> \\[     T_0(x) = 1, T_1(x) = x, T_2(x) = 2x^2 \u2212 1, ..., T_{n+1}(x) = 2xT_n(x) \u2212 T_{n\u22121}(x), \\quad x \\in [\u22121:1] \\equiv \\mathcal{L}, \\quad\\quad  (2) \\label{eq:2} \\] <p></p> <p>which are basis functions widely used to approximate generic (non-periodic) functions defined on finite intervals given their unique convergence properties and close relation to the Fourier transform<sup>1</sup>. It is easy to verify that the Chebyshev polynomials of first kind satisfy the orthogonality relations:</p> <p> \\[     \\int_{\\mathcal{L}} dx \\omega(x) T_n(x) T_m(x) = \\dfrac{1 + \\delta_{n,0}}{2} \\delta_{n,m}, \\quad \\text{with  } \\omega(x) = \\dfrac{1}{\\pi \\sqrt{1 - x^2}}, \\quad\\quad (3) \\label{eq:3} \\] <p></p> <p>and thus form a complete set on \\(\\mathcal{L}\\). </p> <p>The orthogonality relations \\((3)\\) allow us to define the numerically convenient spectral decomposition</p> <p> \\[ f(x)=\\omega(x)\\sum\\limits_{n=0}^\\infty \\frac{2 \\mu_n}{1+ \\delta_n} T_n(x)\\ , \\quad\\quad (4) \\label{eq:4} \\] <p></p> <p>where \\(\\mu_n\\) are the so-called Chebyshev moments defined as the overlaps \\(\\mu_n = \\int_\\mathcal{L} dx f(x) T_n(x)\\).</p> <p>The extension of these concepts to operators (matrices) allows full quantum-mechanical calculations of lattice models to be carried out for extremely large systems bypassing direct diagonalization. For example, the Chebyshev expansion of the familiar spectral operator, \\(\\delta(E\u2212\\hat{H})\\), at the heart of many calculations in condensed matter physics is given by<sup>2</sup>:</p> <p> \\[     \\delta(E-\\hat{H})=\\frac{1}{\\pi \\sqrt{1-E^{2}}} \\sum_{n=0}^{\\infty} \\frac{2}{1+\\delta_{n, 0}} T_{n}(E) \\mathcal{T}_{n}(\\hat{H})\\ , \\quad\\quad (5) \\label{eq:5} \\] <p></p> <p>where \\(||\\hat{H}|| \\leq 1\\) has been re-scaled to guarantee that its spectrum falls into the spectral interval \\(E \\in [\u22121:1]\\). In the above, the operators \\(T_n(\\hat{H})\\) are defined by the matrix version of the standard Chebyshev recursion relations</p> <p> \\[     \\mathcal{T}_{0}=1, \\quad \\mathcal{T}_{1}(\\hat{H})=\\hat{H},      \\quad \\mathcal{T}_{n+1}(\\hat{H})=2 \\hat{H} \\cdot \\mathcal{T}_{n}(\\hat{H})-\\mathcal{T}_{n-1}(\\hat{H}). \\quad\\quad  (6) \\label{eq:6} \\] <p></p> <p>A spectral decomposition into Chebyshev polynomials \\((4)\\) allows straightforward determination of several important quantities, for example, the density of states (DoS):</p> <p> \\[     \\rho(E) \\equiv \\frac{1}{D} \\operatorname{Tr} \\delta(E-\\hat{H}) \\simeq \\frac{1}{\\pi \\sqrt{1-E^{2}}} \\sum_{n=0}^{M-1} \\mu_{n} T_{n}(E), \\quad\\quad (7)  \\label{eq:7} \\] <p></p> <p>where \\(M\\) is the Chebyshev (truncation) order that controls the accuracy of the spectral expansion (see below).  The Chebyshev moments are easily seen to be determined by traces of the matrix Chebyshev operators according to \\(\\mu_{n}=\\text{Tr}\\,[T_{n}(\\hat{H})]/\\chi_{n}\\) with \\(\\chi_n=[D\\left(1+\\delta_{n, 0}\\right)] / 2\\). Clearly, the knowledge of the Chebyshev moments,  \\(\\{\\mu_n\\}\\) (\\(n=0,1,...\\)), allows us to reconstruct the DoS over any desired grid of energies (the so-called post-processing stage).</p> <p>We will now discuss how to efficiently compute \\(\\{\\mu_n\\}\\). Chebyshev moments are typically evaluated recursively in two steps (note that \\(\\mu_0=1\\) by definition). First, a series of matrix-vector multiplications is carried out to construct the Chebyshev matrix polynomials using Eq. \\((6)\\).  The iteration process usually starts with the application of \\(\\mathcal{T}_{1}(\\hat{H})=\\hat{H}\\) onto some basis vector (or a random vector, see the STE part below)  \\(|r_1\\rangle\\), yielding \\(\\hat{H} |r_1\\rangle= |\\tilde r_1 \\rangle\\).  This then allows us to compute the first non-trivial Chebyshev moment, \\(\\mu_1\\), as detailed below. The process is iterated via \\((6)\\)  to compute subsequent moments, \\(\\mu_2\\),  \\(\\mu_3\\), etc.  In practice, the iterative procedure is terminated once the desired energy resolution has been achieved, and, as such, for some problems, the number of Chebyshev moments \\(M\\) required can be quite large.</p> <p>For typical sparse Hamiltonian matrices,  the algorithmic complexity of each Chebyshev step scales favourably as \\(Z \\times D\\), where \\(Z\\) is the lattice coordination. Efficient numerical implementations of the spectral method, such as those within KITE, evaluate these moments \"on-the-fly\" exploiting both the sparseness of real-space lattice models and the stability of the Chebyshev recursive procedure \\((1)\\) (which does not suffer from loss of orthogonality or other numerical instabilities commonly found in other iterative methods).  Moreover, Chebyshev expansions benefit from a uniform resolution due to errors being distributed uniformly on \\(\\mathcal{L}\\)<sup>1</sup>. In principle, the spectral resolution is only limited by the number of moments retained in the expansion. As a rule of thumb, the resolution is inversely proportional to the number of moments used. For functions of \\(E\\) (such as the DoS), this results into \\(\\delta E \\propto \\Delta / M\\), where \\(\\Delta\\) is the original spectrum bandwidth (prior to re-scaling). </p> <p>It is well known that truncated spectral representations often present spurious features known as Gibbs oscillations (Fourier expansions) and Runge phenomenon (polynomial expansions). A well-known example is the \"ringing artifact\" in the Fourier expansion of a square wave signal. Gibbs oscillations can be cured using specialized filtering techniques. An increasingly popular approach in quantum chemistry and computational condensed matter physics is the kernel polynomial method (KPM)<sup>2</sup>. As its name suggests, the KPM makes use of convolutions with a kernel to attenuate the Gibbs oscillations, e.g., for the DOS, \\(\\mu_n \\rightarrow \\mu_n \\times g_n\\). A proper kernel \\(g_n\\) must satisfy specific criteria to guarantee that the approximate function \\(f_M(x)\\) converges to the target function \\(f(x)\\) uniformly as \\(M \\rightarrow \\infty\\). A typical example is the Lorentz kernel, \\(g^L_n = \\sinh(\\lambda(1\u2212n/M))/\\sinh(\\lambda)\\), where \\(\\lambda\\) is an adjustable parameter. It has the property that approximates nascent Dirac-delta functions \\(\\delta_\\eta(x)\\) by a Lorentzian with resolution \\(\\eta = \\lambda / M\\), and thus has been employed to damp Gibbs oscillations in spectral decomposition of broadened Green's functions<sup>2</sup>.</p> <p>A powerful alternative is given by the Chebyshev polynomial Green's function (CPGF) method<sup>3</sup>, which is based on the following exact spectral decomposition of the lattice resolvent operator:</p> <p> \\[     \\hat{\\mathcal{G}}(E+i \\eta)=\\sum_{n=0}^{\\infty} g_{n}(E+i \\eta) \\mathcal{T}_{n}(\\hat{H}),      \\quad \\text { with } g_{n}(z) \\equiv \\frac{2 i^{-1}}{1+\\delta_{n, 0}} \\frac{\\left(z-i \\sqrt{1-z^{2}}\\right)^{n}}{\\sqrt{1-z^{2}}}.  \\quad\\quad (8)  \\label{eq:8} \\] <p></p> <p>Differently from the KPM, the spectral coefficients now depend on the energy. The energy resolution \\(\\eta\\) also enters directly into these coefficients, which allows us to set the target resolution from the outset of the calculation.  Also, being an exact asymptotic expansion, the convergence of the \\(M\\)th-order approximation to \\(G(E)\\) to a given accuracy is guaranteed provided \\(M\\) is large enough. The figure below shows the convergence of the DOS at the band center \\(E = 0\\) of a giant honeycomb lattice with 3.6 billion sites and dilute random defects (vacancies). The CPGF method is seen to converge significantly faster than the KPM. More importantly, the CPGF expansion converges asymptotically at all energies (by contrast, the Lorentz kernel may lead to small errors away from the band centre).  Convergence of \\(M\\)-order approximation to the DOS at the band center of a giant honeycomb lattice with \\(60000 \\times 60000\\) sites and vacancy defect concentration of 0.4% at selected values of energy resolution. As a guide to the eye, we plot the DOS normalized to its converged value (to 0.1% accuracy). As comparison, the DOS obtained from a KPM expansion with a Lorentz kernel is shown (with effective resolution \\(\\eta=1\\) meV).  The number of required moments \\(M\\) increases quickly as electronic states are probed with finer energy resolutions. This poses difficulties when evaluating more complex quantities, such as linear response functions given by products of two Green functions (e.g., longitudinal conductivity<sup>4</sup>), especially at finite temperature/frequency (where off-Fermi surface processes are relevant)<sup>5</sup> or when the system approaches a quantum phase transition<sup>3</sup>.</p> <p>To overcome the above challenge, KITE integrates a number of state-of-the-art algorithms. An example is KITE's large-scale single-shot algorithm for direct evaluation of zero-temperature DC response functions at  fixed Fermi energy. The algorithm bypasses the expensive recursive calculation of moments and thus can treat giant systems (\\(N \\propto 10^{10}\\)) with fine resolution (\\(M\\) up to hundreds thousands). It can be applied to other quantities, such as  DOS, local DOS and quasiparticle self-energy; a detailed description is given in Refs.<sup>3</sup> and <sup>6</sup>. Moreover, a Chebyshev-moment approach to the Kubo-Bastin formula developed in<sup>5</sup> gives access to finite temperature response functions of large systems up to ten millions of orbitals (with \\(M\\) up to tens thousands<sup>3</sup>); a detailed description of the algorithm is given in Ref.<sup>5</sup> and its large-scale implementation in Ref.<sup>3</sup>. Recent developments, which integrate spectral and domain-and-conquer methods to further boost the efficiency of real-space simulations of Kubo formulas, have paved the way to yet larger systems and finer energy resolutions <sup>7</sup>.</p> <p>To speed up the evaluation of the \\(n\\)-body trace operation \\(\\operatorname{Tr}\\{T_n(\\hat{H})...T_m(\\hat{H})\\}\\) (in the DOS example above, \\(\\operatorname{Tr}\\{T_n(\\hat{H})\\}\\)), KITE implements the stochastic trace evaluation technique (STE)<sup>2</sup>:</p> <p> \\[     \\rho_{\\mathrm{STE}}(E)=\\sum_{r=1}^{R}\\langle r|\\delta(E-\\hat{H})| r\\rangle,  \\quad\\quad (9)  \\label{eq9} \\] <p></p> <p>with random vectors \\(|r\\rangle=\\sum_{i=1}^{D} \\chi_{r, i}|i\\rangle\\). Here, \\(\\{|i\\rangle\\}\\) (\\(i=1,...,D\\)) are a complete orthonormal basis set of the lattice model (typically position kets). The random variables \\(\\chi_{r,i}\\) can be real- or complex-valued and fulfill \"white noise\" statistics: \\(\\left\\langle\\left\\langle\\chi_{r, i}\\right\\rangle\\right\\rangle=0, \\quad\\left\\langle\\left\\langle\\chi_{r, i} \\chi_{r^{\\prime}, i^{\\prime}}\\right\\rangle\\right\\rangle=0\\) and \\(\\left\\langle\\left\\langle\\chi_{r, i}^{*} \\chi_{r^{\\prime}, i^{\\prime}}\\right\\rangle\\right\\rangle=\\delta_{r, r^{\\prime}} \\delta_{i, i^{\\prime}}\\). The STE is extremely accurate for sparse matrices of large dimension (only a few random vectors are needed to converge to many decimal places), which allows substantial savings in computational time. For example, the evaluation of Chebyshev moments of the DOS function for a tight-binding model (where \\(D=N\\), and \\(N\\) is the total number of orbitals or sites in the lattice) requires a total number of operations scaling as</p> <p> \\[     P_\\text{DOS} = Z \\times N \\times M \\times R.  \\quad\\quad (10)  \\label{eq:10} \\] <p></p> <p>The required number of random vectors, \\(R\\), depends on sparsity of the Chebyshev polynomial matrices \\(T_n(\\hat{H})\\). For typical tight-binding problems, one has \\(Z \\propto O(1)\\). Thus, in the large system limit \\((N \\gg 1)\\), a single random vector is often enough to achieve accuracy of 1% or better<sup>3</sup>. In fact, for sparse matrices, the STE relative error has the favorable scaling \\(1 / \\sqrt{R N}\\). On the other hand, the number of moments required to converge the expansion depends strongly on the desired resolution, \\(\\eta\\). As a rule of thumb, \\(M\\) should not be smaller than a few times the linear dimension of the system \\(N^{1/d}\\), where \\(d\\) is the number of spatial dimensions, which then leads to:</p> <p> \\[     P_{\\mathrm{DOS}} \\propto N^{1+1 / d}, \\text { for } N \\gg 1,  \\quad\\quad (11)  \\label{eq:11} \\] <p></p> <p>allowing a significant reduction in computational time w.r.t. direct diagonalization techniques, especially in \\(d \\geq 2\\).</p> <ol> <li> <p>Chebyshev and Fourier spectral methods, John P. Boyd, 2nd Ed. Dover 5, New York (2001).\u00a0\u21a9\u21a9</p> </li> <li> <p>Kernel polynomial method, Alexander Wei\u00dfe, Gerhard Wellein, Andreas Alvermann, and Holger Fehske. Rev. Mod. Phys. 78, 275 (2006).\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Critical delocalization of chiral zero energy modes in graphene, A. Ferreira and E. Mucciolo, Phys. Rev. Lett. 115, 106601 (2015).\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Unified description of the dc conductivity of monolayer and bilayer graphene at finite densities based on resonant scatterers, A. Ferreira et al., Phys. Rev. B 83, 165402 (2011).\u00a0\u21a9</p> </li> <li> <p>Real-Space calculation of the conductivity tensor for disordered topological matter, J. H. Garc\u00eda, L. Covaci, and T. G. Rappoport, Phys. Rev. Lett. 114, 116602 (2015).\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>High-resolution real-space evaluation of the self-energy operator of disordered lattices: Gade singularity, spin\u2013orbit effects and p-wave superconductivity, S M Jo\u00e3o, J. M. Viana Parente Lopes, and A. Ferreira, J. Phys. Mater. 5 045002 (2022).\u00a0\u21a9</p> </li> <li> <p>Fast Fourier-Chebyshev approach to real-space simulations of the Kubo Formula, S. G. de Castro, J. M. V. P. Lopes, A. Ferreira, and D. A. Bahamon, Phys. Rev. Lett. 132, 076302  (2024) \u21a9</p> </li> </ol>"},{"location":"background/tight_binding/","title":"Tight-Binding Models","text":"<p>The tight-binding (TB) method (and the closely related linear combination of atomic orbitals (LCAOs) method in quantum chemistry) is a computationally fast and robust approach to handle large-scale molecular and condensed matter systems. In the TB approximation, electrons are assumed to be strongly bound to the nuclei. The one-particle wavefunctions \\(\\{\\psi_{\\alpha}(\\mathbf{x})\\}\\) are approximated by linear combinations of Slater-Koster-type states (i.e., LCAOs) for isolated atoms, i.e.,</p> \\[     \\psi_{\\alpha}(\\mathbf{x}) = \\frac{1}{\\sqrt{N}}\\sum\\limits_{i=1}^N a_\\alpha^{(i)} \\phi_\\text{SK}(\\mathbf{x}-\\mathbf{x}_i), \\] <p>where \\(i=\\{1, \\ldots, N\\}\\) runs over all sites and orbitals. The one-particle states \\(| \\psi_\\alpha \\rangle\\) are eigenvectors of the Hamiltonian matrix (the TB Hamiltonian), \\(\\hat{H} = \\sum_{i,j} t_{i,j} |i\\rangle \\langle j |\\). The TB matrix elements \u2014 encoding on-site energies \\((i = j)\\) and hopping integrals between different atomic orbitals \\((i \\neq j)\\) \u2014 can be estimated for example by means of the Slater-Koster approach or by matching the spectrum to that obtained by first-principles calculations in a suitable reference system<sup>1</sup><sup>2</sup><sup>3</sup><sup>4</sup>.</p> <p>Suitably parameterized TB models provide an accurate description of molecular orbitals in molecules and Bloch wavefunctions in many solids. The complexity of TB models only grows linearly with the number of atomic orbitals, providing a basis for large-scale calculations of a plethora of equilibrium and non-equilibrium physical properties, including optical absorption spectra, simulations of amorphous solids, and wave-packet propagation. Disorder, interfaces, and defects can be conveniently added to a TB model by modifying on-site energies and hopping integrals, and adding auxiliary sites. Such a multi-scale approach has proven very successful in describing impurity scattering<sup>5</sup><sup>6</sup>, moir\u00e9 patterns<sup>7</sup>, complex scattering potentials induced by ad-atoms<sup>8</sup>, optical conductivity of disordered 2D materials<sup>9</sup>, and geometrical properties, vibrational frequencies and non-covalent interactions of large molecular systems<sup>10</sup>.</p> <ol> <li> <p>Simplified LCAO method for the periodic potential problem, J. C. Slater and G. F. Koster, Phys. Rev. 94, 1498 (1954) \u21a9</p> </li> <li> <p>Elementary prediction of linear combination of atomic orbitals matrix elements, S. Froyen and W.A. Harrison, Phys. Rev. B 20, 2420 (1979) \u21a9</p> </li> <li> <p>Tight-binding modelling of materials, C. M. Goringe, D. R. Bowler, and E. Hern\u00e1ndez, Rep. Prog. Phys. 60, 1447 (1997) \u21a9</p> </li> <li> <p>The Slater\u2013Koster tight-binding method: a computationally efficient and accurate approach, D. A. Papaconstantopoulos and M. J. Mehl, Journal of Physics: Condensed Matter 15, R413 (2003) \u21a9</p> </li> <li> <p>Resonant scattering by realistic impurities in graphene, T. O. Wehling et al. Phys. Rev. Lett. 105, 056802 (2010) \u21a9</p> </li> <li> <p>Unified description of the dc conductivity of monolayer and bilayer graphene at finite densities based on resonant scatterers, A. Ferreira et al., Phys. Rev. B 83, 165402 (2011) \u21a9</p> </li> <li> <p>Ab initio theory of moir\u00e9 superlattice bands in layered two-dimensional materials, J. Jung, A. Raoux, Z. Qiao, and A. H. MacDonald, Phys. Rev. B 89, 205414 (2014) \u21a9</p> </li> <li> <p>Impact of complex adatom-induced interactions on quantum spin Hall phases. F. J. dos Santos et al., Phys. Rev. B 98, 081407(R) (2018) \u21a9</p> </li> <li> <p>Numerical calculation of the Casimir-Polder interaction between a graphene sheet with vacancies and an atom. T. Cysne et al., Phys. Rev. B 94, 235405 (2016) \u21a9</p> </li> <li> <p>A robust and accurate tight-binding quantum chemical method for structures, vibrational frequencies, and noncovalent interactions of large molecular systems parametrized for all spd-block elements (Z = 1\u221286), S. Grimme , C. Bannwarth, and P. Shushkov, J. Chem. Theory Comput., 13 , 1989 (2017) \u21a9</p> </li> </ol>"},{"location":"documentation/","title":"Tutorial","text":"<p>This tutorial covers the basic aspects that are necessary to start using KITE. You will learn about the different steps in KITE's workflow and how to adjust the different parameters.</p> <p>The tutorial is structured as follows:</p> <ol> <li>Learning KITE's workflow</li> <li>Building a tight-binding model using <code>pb.Lattice</code></li> <li>How to define the settings for KITE simulations</li> <li>How to calculate the different target functions </li> <li>Post-processing the results with KITE-tools</li> <li>Adding disorder or a magnetic field to the tight-binding model</li> <li>How to edit the HDF5-file</li> <li>Optimizing the settings for various calculations</li> </ol> <p>First calculation with KITE</p> <p>Let us perform a simple first calculation with KITE. (Do not worry about the fine details just now, these will be covered later in the tutorial.)</p> <p>Tip</p> <p>Run this example from the <code>kite/</code>-folder to have acces to KITE's python package.</p> <pre><code>import kite\nimport numpy as np\nimport matplotlib.pyplot as plt \nfrom pybinding.repository import graphene\nfrom os import system as terminal\n\nconf = kite.Configuration(divisions=[4, 4], length=[512, 512], boundaries=[\"periodic\", \"periodic\"])\ncalc = kite.Calculation(conf)\ncalc.dos(num_points=4000, num_moments=512, num_random=2, num_disorder=1)\nkite.config_system(graphene.monolayer(), conf, calc, filename=\"first_calculation.h5\")\n\nterminal(\"build/KITEx first_calculation.h5\")\nterminal(\"tools/build/KITE-tools first_calculation.h5\")\n\ndos = np.loadtxt(\"dos.dat\")\nplt.plot(dos[:, 0], dos[:, 1])\nplt.xlabel(\"Energy (eV)\")\nplt.ylabel(\"Density of States (a.u)\")\nplt.show()\n</code></pre> <p> The result from your first KITE calculation: the density of states of monolayer graphene. </p> <p>Examples\" and \"More Examples</p> <p>Section Examples contains step-by-step examples aimed to expand on key concepts covered by the Tutorial. Additional resources are provided in More examples.</p>"},{"location":"documentation/calculation/","title":"4. Calculation","text":"<p>The <code>kite.Calculation</code> object contains the information required to calculate desired quantities, i.e. the target functions. Key parameters of the calculation are included here, such as the Chebyshev expansion order and number of disorder realizations. These are used by KITEx to calculate the spectral coefficients. Subsequently,  at the post-processing stage, KITE-tools can be used, e.g. to reconstruct the full energy dependence of the desired target function (see Workflow). The parameters given in the Examples are optimized for relatively small systems and are therefore ideal to run KITE with a standard desktop computer or laptop.</p> <p>The target functions currently available are:</p> <ul> <li> <code>dos</code> Calculates the average density of states (DOS) as a function of energy. </li> <li> <code>ldos</code> Calculates the local density of states (LDOS) as a function of energy (for a set of lattice positions). </li> <li> <code>arpes</code> Calculates the one-particle spectral function of relevance to ARPES. </li> <li> <code>gaussian_wave_packet</code> Simulates the propagation of a gaussian wave-packet. </li> <li> <code>conductivity_dc</code> Calculates a given component of the DC conductivity tensor. </li> <li> <code>conductivity_optical</code> Calculates a given component of the linear optical conductivity tensor. </li> <li> <code>conductivity_optical_nonlinear</code> Calculates a given component of the 2nd-order nonlinear optical conductivity tensor. </li> <li> <code>singleshot_conductivity_dc</code> Calculates the longitudinal DC conductivity for a set of Fermi energies (uses the \\(\\propto\\mathcal{O}(N)\\) single-shot method). </li> </ul> <p>The table below shows to which level the KITE target functions have been implemented and tested at the time of writing (May, 2025).  Note that the non-linear optical conductivity functionality is currently restricted to 2D systems.</p> Method 2D 3D <code>dos</code> <code>ldos</code> <code>arpes</code> <code>gaussian_wave_packet</code> <code>conductivity_dc</code> <code>conductivity_optical</code> <code>conductivity_optical_nonlinear</code> <code>magnetic_field</code> <code>singleshot_conductivity_dc</code> <p> - Checked and extensively used</p> <p> - Implemented and checked</p> <p> - Not yet implemented</p> <p>All target functions require the following parameter:</p> <ul> <li> <code>num_moments</code> Defines the order of Chebyshev expansions and hence the effective energy resolution of the calculation; see Documentation. </li> </ul> <p>Other common parameters are:</p> <ul> <li> <code>num_random</code> Defines the number of random vectors used in the stochastic trace evaluation. </li> <li> <code>num_disorder</code> Defines the number of disorder realizations (and automatically specifies the boundary twist angles if the <code>\"random\"</code> boundary mode is chosen; see Settings). </li> </ul> <p>Some functions also require the following parameters:</p> <ul> <li> <code>direction</code> Specifies the component of the linear (longitudinal: (<code>'xx'</code>, <code>'yy'</code>, <code>'zz'</code>), transversal: (<code>'xy'</code>, <code>'yx'</code>, <code>'xz'</code>, <code>'yz'</code>)) or the nonlinear conductivity tensor (e.g., <code>'xyx'</code> or <code>'xxz'</code>) to be calculated. </li> <li> <code>temperature</code> (can be modified at post-processing level) Temperature of the Fermi-Dirac distribution used to evaluate optical and DC conductivities.  <code>temperature</code> specifies the quantity \\(k_B T\\), which has units of <code>energy</code>. For example, if the hoppings are given in eV, <code>temperature</code> must be given in eV.  </li> <li> <code>num_points</code> (can be modified at post-processing level) Number of energy points used by the post-processing tool to output the <code>dos</code> and other target functions. </li> <li> <code>energy</code> Selected values of Fermi energy at which we want to calculate the <code>singleshot_conductivity_dc</code>. </li> <li> <code>eta</code> Imaginary constant (scalar self energy) in the denominator of the Green's function required for lattice calculations of finite-size systems, i.e. an energy resolution (can also be seen as a controlled broadening or inelastic energy scale). For technical details, see Documentation. </li> </ul> <p>The <code>calculation</code> is structured in the following way:</p> <pre><code>calculation = kite.Calculation(configuration)\ncalculation.dos(\n    num_points=1000,\n    num_random=10,\n    num_disorder=1,\n    num_moments=512\n)\ncalculation.conductivity_optical(\n    num_points=1000,\n    num_random=1,\n    num_disorder=1,\n    num_moments=512,\n    direction='xx'\n)\ncalculation.conductivity_dc(\n    num_points=1000,\n    num_moments=256,\n    num_random=1,\n    num_disorder=1,\n    direction='xy',\n    temperature=1\n)\ncalculation.singleshot_conductivity_dc(\n    energy=[(n / 100.0 - 0.5) * 2 for n in range(101)],\n    num_moments=256,\n    num_random=1,\n    num_disorder=1,\n    direction='xx',\n    eta=0.02\n)\ncalculation.conductivity_optical_nonlinear(\n    num_points=1000,\n    num_moments=256,\n    num_random=1,\n    num_disorder=1,\n    direction='xxx',\n    temperature=1.0,\n    special=1\n)\n</code></pre> <p>Note</p> <p>The user can decide what functions are used in a calculation. However, it is not possible to configure the same function twice in the same configuration file.</p> <p>When these objects are defined, we can set up the I/O instructions for KITEx using the <code>kite.config_system</code> function: <pre><code>kite.config_system(lattice, configuration, calculation, filename='test.h5')\n</code></pre> Export the KITE model to the I/O HDF file, by running  <pre><code>python3 script_name_here.py\n</code></pre></p>"},{"location":"documentation/calculation/#running-a-calculation","title":"Running a Calculation","text":"<p>To run the code and to post-process it, run from the <code>kite/</code>-directory</p> <pre><code>./build/KITEx test.h5\n./build/KITE-tools test.h5\n</code></pre> <p>KITE-tools output</p> <p>The output of KITE-tools is dependent on the target function specified by the user. Each specific case is described in the API. This output is generally a <code>\"*.dat\"</code>-file where the various columns of data contain the required target functions.</p>"},{"location":"documentation/calculation/#visualizing-the-output-data","title":"Visualizing the Output Data","text":"<p>After calculating and post-processing the target functions, we can plot the resulting data with the following script:</p> <pre><code>data=np.loadtxt('dos.dat')\n\nplt.plot(data[:,0], data[:,1])\nplt.xlabel('E (eV)')\nplt.ylabel('DOS (a.u)')\n</code></pre> <p>A more streamlined approach would be to use a Bash script, for example:</p> <pre><code>#!/bin/bash\n\nfile_out=example1                 # name of python script that exports the HDF5-file\nfile_in=example1                  # name of the exported HDF5-file\n\npython ${file_out}.py             # make a model\n./build/KITEx ${file_in}.h5       # run Kite\n\n./build/KITE-tools ${file_in}.h5  # run the post-processing steps\npython plot_dos.py                # display the data\n</code></pre>"},{"location":"documentation/disorder/","title":"6. Disorder","text":"<p>KITE's general-purpose and user-friendly disorder implementation is one of its main features. The inclusion of disorder in a given system follows a simple but effective recipe: users select a default disorder type or define their own disorder patterns in the Python interface to create a bespoke disorder landscape. This information is passed on to KITEx and used to automatically perform the required modifications of on-site energies and hopping terms across the whole lattice on-the-fly.</p> <p>Info</p> <p>Disorder patterns are local modifications of the Hamiltonian that can be constricted to one unit cell or can connect neighboring unit cells.  The local patterns are randomly distributed over the whole lattice with a desired concentration. This framework is thus ideal to simulate systems with random impurities/defects of specified types. </p> <p>KITE handles both standard uncorrelated disorder (e.g., random on-site energies) and realistic short-range disorder (e.g., vacancies or impurity scattering centers distributed randomly over the lattice sites with a specified concentration). KITE can even handle multiple disorder patterns simultaneously.</p>"},{"location":"documentation/disorder/#disorder-implementation","title":"Disorder implementation","text":"<p>After defining a regular lattice, disorder can be added to the system. KITE allows the user to select between on-site and structural disorder by choosing between predefined classes in the Python interface. The interface provides two different classes of disorder:</p> <ul> <li><code>kite.Disorder</code> - onsite disorder with two possible statistical distributions</li> <li><code>kite.StructuralDisorder</code> - multi-orbital impurities and defects (including bond disorder) with a given concentration</li> </ul>"},{"location":"documentation/disorder/#on-site-disorder","title":"On-site disorder","text":"<p><code>kite.Disorder</code> adds randomly generated on-site terms at the sites of a desired sublattice drawn from one of the two statistical distributions:</p> <ul> <li>Gaussian</li> <li>Uniform</li> </ul> <p>One can select a sublattice hosting a particular disorder, and specify the mean value and the standard deviation of the selected distribution. To include on-site disorder, one builds the <code>pb.lattice</code> and use the following procedure:</p> <pre><code># define an object based on the lattice\ndisorder = kite.Disorder(lattice)\n# add Gaussian distributed disorder at all sites of a selected sublattice (A in this example)\ndisorder.add_disorder('A', 'Gaussian', mean, std)\n</code></pre> <p>In a single object it is possible to select multiple sublattices, each with its own disorder distribution following the rule <code>kite.Disorder.add_disorder('sublattice', 'type', mean, std)</code>. For example,</p> <pre><code>disorder.add_disorder('A', 'Gaussian', 0.1, 0.1)\ndisorder.add_disorder('B', 'Uniform', 0.2, 0.1)\n</code></pre> <p>The final step consists of adding the disorder as an additional parameter into the <code>kite.config_system</code> function:</p> <pre><code>kite.config_system(..., disorder=disorder)\n</code></pre> <p>A complete example that calculates the average density of states of graphene with different on-site disorder distributions on each sublattice is given below:</p> <pre><code>\"\"\" Onsite disorder\n    Lattice : Monolayer graphene (from Pybinding repository);\n    Disorder : Uncorrelated on-site disorder (uniform PDF) on single sublattice;\n    Configuration : size of the system 1024\u00d71024, with domain decomposition (nx=ny=2),\n                    periodic boundary conditions,\n                    double precision, automatic scaling;\n    Calculation : DOS;\n    Modification : magnetic field is off;\n\"\"\"\n\nimport kite\nimport numpy as np\nfrom pybinding.repository import graphene\n\n# load graphene lattice from Pybinding repository \nlattice = graphene.monolayer(nearest_neighbors=1,onsite=(0,0),t=-2.7)\n\n# add Disorder\ndisorder = kite.Disorder(lattice)\nmean = 1.5 # mean\nstd  = 1.0 # standard deviation\ndisorder.add_disorder('A', 'Uniform', mean, std)\n\n# Manual rescaling: lower/upper bounds on smallest/largest energy eigenvalue\nt = -2.7\nEmax = 3*np.abs(t) + mean + np.sqrt(3)*std\nEmin = -3*np.abs(t) + mean - np.sqrt(3)*std\n\n# Calculation settings\nnx = ny = 2    #number of decomposition parts\nlx = ly = 1024 #number of unit cells in each direction\n# Boundary Mode\nmode = \"periodic\"\nconfiguration = kite.Configuration(\n    divisions=[nx, ny],\n    length=[lx, ly],\n    boundaries=[mode, mode],\n    is_complex=False,\n    precision=1,\n    spectrum_range=[Emin,Emax])\n\n# require the calculation of DOS\ncalculation = kite.Calculation(configuration)\ncalculation.dos(num_points=5000, num_moments=512, num_random=1, num_disorder=1)\n# configure the *.h5 file\nkite.config_system(lattice, configuration, calculation, filename='on_site_disorder.h5', disorder=disorder)\n</code></pre> DOS for the on-site disorder example."},{"location":"documentation/disorder/#structural-disorder","title":"Structural disorder","text":"<p>The <code>kite.StructuralDisorder</code> class adds the possibility of selecting between two different short-range disorder types:  vacancy defects randomly distributed with a certain concentration over lattice sites on a selected sublattice,  and a more generic multi-orbital disorder which may combine on-site and hopping terms (also randomly distributed with a certain concentration).</p>"},{"location":"documentation/disorder/#example-1-vacancy-defects","title":"Example 1: vacancy defects","text":"<p>To add vacancy defects with a given <code>concentration</code> on a single sublattice, one uses the simple instruction:</p> <pre><code>struc_disorder = kite.StructuralDisorder(lattice, concentration=0.2)\nstruc_disorder.add_vacancy('B') # add a vacancy to a selected sublattice\n</code></pre> <p>Note</p> <p>To distribute the vacancies on both sublattices (compensated or otherwise), one needs to treat each sublattice as a separate object of the class <code>kite.StructuralDisorder</code></p> <pre><code>struc_disorder_A = kite.StructuralDisorder(lattice, concentration=0.1)\nstruc_disorder_A.add_vacancy('A')\nstruc_disorder_B = kite.StructuralDisorder(lattice, concentration=0.1)\nstruc_disorder_B.add_vacancy('B')\ndisorder_structural = [struc_disorder_A, struc_disorder_B]\n</code></pre>"},{"location":"documentation/disorder/#example-2-mixed-on-sitebond-disorder","title":"Example 2: Mixed on-site/bond disorder","text":"<p>The following example illustrates KITE's most general type of short-range disorder, which includes both atomic defects (vacancies) and bond modifications. This type of disorder can be added as an object of the class <code>kite.StructuralDisorder</code>. The procedure is analogous to adding a hopping term to the Pybinding lattice object. </p> <p>An important remark is in order. KITE's structural disorder functionality is rather general and allows users to create bespoke disorder landscapes for their simulations, while benefiting from KITE's efficient domain decomposition algorithm. However, as mentioned in Sec. 2 - Lattice, it is assumed by default that all hopping terms in the model connect sites that belong to either the same unit cell or neighboring cells that are separated by at most 2 lattice spacings along a given direction. This applies equally to the disorder patterns as they are an inherent part of the lattice model. To relax this constraint, the users must adjust  the NGHOSTS parameter in <code>kite/Src/Generic.hpp</code> and recompile KITEx, otherwise an error message is output and the KITE program exits. </p> <p>Let us begin by defining the sublattices that will constitute the disorder. In this case we are not restricted to a single unit cell:</p> <pre><code>#  define a node in a unit cell [i, j] selecting a single sublattice\nnode0 = [[+0, +0], 'A']\nnode1 = [[+0, +0], 'B']\nnode2 = [[+1, +0], 'A']\nnode3 = [[+0, +1], 'B']\nnode4 = [[+0, +1], 'A']\nnode5 = [[-1, +1], 'B']\n</code></pre> <p>After defining a parent  <code>kite.StructuralDisorder</code> object, we can construct the desired pattern:</p> <pre><code> # define an object based on the lattice with a certain concentration\nstruc_disorder = kite.StructuralDisorder(lattice, concentration=0.2)\n\nstruc_disorder.add_structural_disorder(\n    # add bond disorder in the form\n    #  [from unit cell], 'sublattice_from', [to_unit_cell], 'sublattice_to', value:\n    (*node0, *node1, 0.5),\n    (*node1, *node2, 0.1),\n    (*node2, *node3, 0.5),\n    (*node3, *node4, 0.3),\n    (*node4, *node5, 0.4),\n    (*node5, *node0, 0.8),\n    # in this way we can add onsite disorder in the form [unit cell], 'sublattice', value\n    ([+0, +0], 'B', 0.1)\n)\n\n# It is possible to add multiple different disorder types which\n#  should be forwarded to the config_system function as a list.\nanother_struc_disorder = kite.StructuralDisorder(lattice, concentration=0.6)\nanother_struc_disorder.add_structural_disorder(\n    (*node0, *node1, 0.05),\n    (*node4, *node5, 0.4),\n    (*node5, *node0, 0.02),\n    ([+0, +0], 'A', 0.3)\n)\n</code></pre> <p>Before exporting the settings to the HDF5-file, it is possible to define multiple disorder realizations which will be superimposed to the clean system.</p> <p>The following script contains a brief example of how to configure the structural disorder:</p> <pre><code>\"\"\" Mixed short-range disorder\n    Lattice : Monolayer graphene (from Pybinding repository);\n    Disorder : StructuralDisorder class - bond and vacancy disorder;\n    Configuration : size of the system 1024x1024, with domain decomposition (nx=ny=2),\n                    periodic boundary conditions,\n                    double precision, manual scaling;\n    Calculation : DOS;\n    Modification : magnetic field is off;\n\"\"\"\n\nimport kite\nimport numpy as np\nfrom pybinding.repository import graphene\n\n#load graphene lattice from Pybinding repository\nlattice = graphene.monolayer(nearest_neighbors=1,onsite=(0,0),t=-2.7)\n\n# Add short-range mixed disorder as an object of a class StructuralDisorder.\n# In this manner we can add onsite and bond defects with a specific concentration.\n\nnode0 = [[+0, +0], 'A']\nnode1 = [[+0, +0], 'B']\nnode2 = [[+1, +0], 'A']\nnode3 = [[+0, +1], 'B']\nnode4 = [[+0, +1], 'A']\nnode5 = [[-1, +1], 'B']\n\nstruc_disorder_one = kite.StructuralDisorder(lattice, concentration=0.05)\nstruc_disorder_one.add_structural_disorder(\n\n# add bond disorder in the form\n# [from unit cell], 'sublattice_from', [to_unit_cell], 'sublattice_to', value:\n(*node0, *node1, 1),\n(*node1, *node2, 1),\n(*node2, *node3, 1),\n(*node3, *node4, 1),\n(*node4, *node5, 1),\n(*node5, *node0, 1),\n# in this way we can add onsite disorder in the form [unit cell], 'sublattice', value\n([+0, +0], 'B', 0.3))\n\n# It is possible to add multiple different disorder types which\n# should be forwarded to the export_lattice function as a list.\n\nstruc_disorder_two = kite.StructuralDisorder(lattice, concentration=0.2)\nstruc_disorder_two.add_structural_disorder(\n    (*node0, *node1, 0.4),\n    (*node4, *node5, 0.4),\n    (*node5, *node0, 0.4),\n    ([+0, +0], 'B', 0.4))\n\nstruc_disorder_two.add_vacancy('B')\n\nstruc_disorder_three = kite.StructuralDisorder(lattice, concentration=0.01)\nstruc_disorder_three.add_vacancy('A')\n\n# if there is disorder it should be returned separately from the lattice\ndisorder_structural = [struc_disorder_one, struc_disorder_two, struc_disorder_three]\n\n# Manual rescaling: lower/upper bounds on smallest/largest energy eigenvalue\n\nt = -2.7\nEmax = 3*np.abs(t)*1.2 \nEmin = -3*np.abs(t)*1.2\n\n#Calculation settings\n\nnx = ny = 2     #number of decomposition parts\nlx = ly = 1024  #number of decomposition parts \n\n#Boundary mode\nmode = \"periodic\"\nconfiguration = kite.Configuration(\n    divisions=[nx, ny],\n    length=[lx, ly],\n    boundaries=[mode, mode],\n    is_complex=False,\n    precision=1,\n    spectrum_range=[Emin,Emax])\n\n# require the calculation of DOS\ncalculation = kite.Calculation(configuration)\ncalculation.dos(num_points=5000, num_moments=512, num_random=1, num_disorder=1)\n\n# configure the *.h5 file\nkite.config_system(lattice, configuration, calculation, filename='mixed_disorder.h5',\n                   disorder_structural=disorder_structural)\n</code></pre> <p>with the resulting density of states:</p> DOS for the structural disorder example."},{"location":"documentation/editing_hdf_files/","title":"8. Editing an HDF5 file","text":""},{"location":"documentation/editing_hdf_files/#what-is-an-hdf-file","title":"What is an HDF file?","text":"<p>The following description of an HDF file has been adapted from HDF:</p> <p>Hierarchical Data Format 5 (HDF5) is a unique open source technology suite for managing data collections of all sizes and complexity. HDF5 has features of other formats, but it can do much more. HDF5 is similar to XML in that HDF5 files are self-describing and allow users to specify complex data relationships and dependencies. In contrast to XML documents, HDF5 files can contain binary data (in many representations) and allow direct access to part of the file without first parsing the entire contents.</p> <p>HDF5 also allows hierarchical data objects to be expressed in a natural manner (similar to directories and files), in contrast to the tables in a relational database. Whereas relational databases support tables, HDF5 supports n-dimensional datasets and each element in the dataset may itself be a complex object. Relational databases offer excellent support for queries based on field matching, but are not well-suited for sequentially processing all records in the database or for selecting a subset of the data based on coordinate-style lookup.</p>"},{"location":"documentation/editing_hdf_files/#editing-the-file","title":"Editing the file","text":"<p>Leveraging its underlying Chebyshev approach, KITE can easily recalculate a physical quantity for different choices of parameters at the post-processing level, i.e. without the need for recalculating Chebyshev moments. As explained in the Post-processing tools documentation, this can be done via several options available in KITE-tools. Here, we discuss an alternative (more advanced) approach, based on the editing of the HDF file.  Suppose we would like to change the post-processing parameters specified when first creating the HDF file (e.g., the temperature or number of energy points of a conductivity calculation). For that purpose, we provide a simple Python script that rewrites specific parts of our .h5 files. As discussed above, the .h5 contains hierarchical data objects that are similar to the structure of directories and files.</p> <p>When modifying a parameter, such as temperature, we begin by locating it in the HDF file. The script below describes how to list and edit the parameters in an HDF file.</p> <pre><code>file_name = 'archive.h5'\nf = h5py.File(file_name, 'r+')     # open the file\n\n# List all groups\nprint('All groups')\nfor key in f.keys():  # Names of the groups in HDF5 file.\n    print(key)\nprint()\n\n# Get the HDF5 group\ngroup = f['Calculation']\n\n# Checkout what keys are inside that group.\nprint('Single group')\nfor key in group.keys():\n    print(key)\nprint()\n#if you want to modify other quantity, check de list and change the subgroup below\n# Get the HDF5 subgroup\nsubgroup = group['conductivity_dc']\n\n# Checkout what keys are inside that subgroup.\nprint('Subgroup')\nfor key in subgroup.keys():\n    print(key)\nprint()\n\nnew_value = 70\ndata = subgroup['Temperature']  # load the data\ndata[...] = new_value  # assign new values to data\nf.close()  # close the file\n\n# To confirm the changes were properly made and saved:\n\nf1 = h5py.File(file_name, 'r')\nprint(np.allclose(f1['Calculation/conductivity_dc/Temperature'].value, new_value))\n</code></pre>"},{"location":"documentation/magnetic/","title":"7. Magnetic Fields","text":"<p>Static \\(\\mathbf{B}\\)-fields are an important case of lattice modifications that can be performed automatically by KITE.  This feature is of particular interest to the study of Landau levels, magneto-transport and magneto-optical effects, among others.</p>"},{"location":"documentation/magnetic/#uniform-b-fields-in-kite-overview","title":"Uniform B-fields in KITE: overview","text":"<p>The automated \\(\\mathbf{B}\\)-field functionality works by the addition of Peierls phases in the Hamiltonian and can be used in conjunction with other lattice modifications, including disorder. This is a new feature under development that currently allows for:</p> <ul> <li>Uniform \\(\\mathbf{B}\\) fields in 2D lattices (with the B-field perpendicular to the plane)</li> <li>Uniform \\(\\mathbf{B}\\) fields in 3D lattices (with the B-field collinear to the third primitive lattice vector)</li> </ul> <p>The \\(\\mathbf{B}\\)-field is added by using the following KITE modification:</p> <pre><code>modification = kite.Modification(magnetic_field = mag)\n</code></pre> <p>where (<code>mag</code>) is the magnetic field strength (given in Tesla). When used with periodic boundary conditions, \\(|\\mathbf{B}|\\) is restricted to be a multiple of a minimum magnetic field, which is determined internally when generating the configuration file (see details below). </p> <p>For example, to compute the DOS of a disordered system subject to the \\(\\mathbf{B}\\)-field modification outlined above, one may use</p> <p><pre><code>calculation.dos(\n    num_points=100,\n    num_moments=5000,\n    num_random=10,\n    num_disorder=10\n)\nmod_mag_field = kite.Modification(magnetic_field = mag)\nkite.config_system(\n    lattice,\n    configuration,\n    calculation,\n    modification=mod_mag_field,\n    disorder=disorder,\n    filename=\"B_field.h5\"\n)\n</code></pre> Here, the configuration file requests a DOS calculation with <code>5000</code> Chebyshev moments, <code>10</code> random vectors and <code>10</code> disorder realizations. Note the addition of the lattice modification (<code>modification=mod_mag_field</code>) with respect to the settings as discussed in the section about disorder.</p>"},{"location":"documentation/magnetic/#implementation-details","title":"Implementation details","text":"<p>Units</p> <p>Lattice parameters must be given in nanometers (see example <code>dos_dccond_square_lattice.py</code> in the <code>bash kite/examples/</code>-folder).</p> <p>The magnetic fields considered in KITE are uniform, so the corresponding vector potential is linear. It is naturally expressed in terms of the primitive reciprocal lattice vectors (\\(\\mathbf{b}_{i=1,2,3}\\)) in the Landau gauge</p> \\[ \\mathbf{A}\\left(\\mathbf{r}\\right)=\\frac{h}{\\left(2\\pi\\right)^{2}e}\\frac{n}{N_{2}}\\left(\\mathbf{r}\\cdot\\mathbf{b}_{2}\\right)\\mathbf{b}_{1} \\] <p>where \\(h\\) is Planck's constant, \\(e&gt;0\\) is the elementary charge, \\(N_{2}\\) is the number of unit cells along the \\(\\mathbf{a}_{2}\\) direction (primitive vector of the direct lattice) and \\(n\\) is an integer. The corresponding magnetic field points along the \\(\\mathbf{a}_{3}\\) direction for 3D systems and perpendicularly to the basal plane (\\(\\mathbf{e}_{\\perp}\\equiv\\hat{\\mathbf{z}}\\)) for 2D systems:</p> \\[ \\mathbf{B}=\\begin{cases} \\frac{h}{e\\Omega_{c}}\\frac{n}{N_{2}}\\mathbf{a}_{3} &amp; (\\textrm{3D})\\\\ \\\\ \\frac{h}{e\\Omega_{c}}\\frac{n}{N_{2}}\\hat{\\mathbf{z}} &amp; (\\textrm{2D}) \\end{cases} \\] <p>and is restricted to be a multiple of a minimum field </p> \\[ B_{\\textrm{min}}=\\frac{h}{e\\Omega_{c}}\\frac{1}{N_{2}}\\times\\begin{cases} |\\mathbf{a}_{3}| &amp; (\\textrm{3D})\\\\ \\\\ 1 &amp; (\\textrm{2D}) \\end{cases} \\] <p>where \\(\\Omega_{c}\\) is the 3D/2D volume of the unit cell.  When the user requests a magnetic field strength \\(|\\mathbf{B}|\\) (given in Tesla), KITE calculates \\(B_{\\textrm{min}}\\) first and then uses that to determine the required \\(n\\) to achieve the closest possible value of \\(|\\mathbf{B}|\\) by rounding \\(|\\mathbf{B}|/\\mathbf{B}_{\\textrm{min}}=n\\) to the nearest integer. If \\(n\\) rounds down to zero, it means that the system is too small to support the requested magnetic field. When determining \\(B_{\\textrm{min}}\\),  KITE assumes that the primitive vectors in the Python configuration script are given in nanometers.</p>"},{"location":"documentation/optimization/","title":"0. Ground Rules","text":"<p>Info</p> <p>Here, we briefly introduce the main concepts underlying all spectral methods currently implemented in KITE. The focus is placed on the role of the simulation parameters that can be adjusted by the end user in order to suit their specific purposes.</p>"},{"location":"documentation/optimization/#the-ground-rules-for-spectral-methods","title":"The Ground Rules for Spectral Methods","text":"<p>The central object to any calculation done in KITE is the lattice single-particle Hamiltonian (SPH) \u2014 \\(H\\) \u2014 which is always a sparse \\(D\\!\\times\\!D\\) hermitian matrix (\\(D\\) being the total number of orbitals in the lattice). This fully embodies the simulated system, from its underlying bravais lattice structure and local orbital basis, to all the non-periodic terms that realize disordered potentials, specific boundary conditions, complex structural defects and external magnetic fields.</p> <p>Any finite-dimensional SPH has a bounded real-valued spectrum which must be shifted and rescaled to suitably fit within \\([-1,1]\\), the convergence interval of the method. This conversion is performed internally by KITE, which transforms \\(H\\to\\mathcal{H}=(H\\!-\\!\\varepsilon_{0})/\\delta\\varepsilon\\) and rescales all energy variables by \\(\\delta\\varepsilon\\). This step requires an early (over)estimation of \\(H\\)'s spectral bandwidth, which can be set manually (using <code>spectrum_range</code> = \\([\\,\\varepsilon_{0}\\!-\\!\\delta\\varepsilon/2\\),\\(\\,\\varepsilon_{0}\\!+\\!\\delta\\varepsilon/2]\\) in <code>kite.Configuration()</code>), or be automatically done by KITE upon generation of the hdf5 configuration file. At this stage, the user must also specify:</p> <ol> <li>The dimensions of the simulated lattice, <code>length=[lx,ly,(lz)]</code>;</li> <li>The number of subdivisions for parallelization of the matrix-vector operation, <code>divisions=[nx,ny,(nz)]</code>,    where \\(n_{x}n_{y}n_{z}\\) (or \\(n_{x}n_{y}\\) for 2D models) is the available CPU-cores;</li> <li>The type of boundary conditions;</li> <li>The type of data to be handled in internal arithmetic operations (for further information see Settings).</li> </ol> <p>Generally, a target function \\(\\mathcal{Q}\\) evaluated by <code>KITEx</code> fits one of the following forms:</p> \\[     \\mathcal{Q}\\left(\\left\\{ \\lambda_{i}^{j}\\right\\} \\right)=\\begin{cases} \\text{Tr}\\left[F_{1}\\left(\\left\\{ \\lambda_{i}^{1}\\right\\};\\mathcal{H}\\right)\\mathcal{O}_{1}F_{2}\\left(\\left\\{ \\lambda_{i}^{2}\\right\\};\\mathcal{H}\\right)\\mathcal{O}_{2}\\cdots\\mathcal{O}_{N}F_{N}\\left(\\left\\{ \\lambda_{i}^{N}\\right\\};\\mathcal{H}\\right)\\right]\\\\ \\left\\langle \\Psi\\right|F_{1}\\left(\\left\\{ \\lambda_{i}^{1}\\right\\};\\mathcal{H}\\right)\\mathcal{O}_{1}F_{2}\\left(\\left\\{ \\lambda_{i}^{2}\\right\\};\\mathcal{H}\\right)\\mathcal{O}_{2}\\cdots\\mathcal{O}_{N}F_{N}\\left(\\left\\{ \\lambda_{i}^{N}\\right\\};\\mathcal{H}\\right)\\left|\\Psi\\right\\rangle  \\end{cases}\\,\\,\\, , \\] <p>where \\(\\mathcal{O}_{j}\\) are sparse lattice operators (e.g., identities, velocity operators or spin operators) and \\(F_{j}\\) are functions of \\(\\mathcal{H}\\), as well as other scalar parameters  \\(\\left\\{ \\lambda_{i}^{j}\\right\\} _{i=i_{min},...,i_{max}}^{j=1,...,N}\\), such as the temperature or frequency. Furthermore, the \\(\\left|\\Psi\\right\\rangle\\) in the second line of the above equation is a specific state/basis vector that depends on the observable that is being computed. Hence, there are two distinct categories of observables that can be computed with  <code>KITEx</code>, as shown below.</p>"},{"location":"documentation/optimization/#traces-over-the-full-hilbert-space","title":"Traces Over The Full Hilbert Space","text":"Complete traces of operators are needed to investigate global observables, such as the Density of States (DoS) and DC-conductivity, as well as the \\(1^{\\text{st}}\\)- and \\(2^{\\text{nd}}\\)-order optical conductivity (see Jo\u00e3o et al.<sup>1</sup> for further details). For all these cases, the trace is evaluated stochastically as an average of expectation values for \\(R\\) normalized random vectors<sup>2</sup>, i.e., \\[   \\text{Tr}\\left[\\cdots\\right]\\approx\\frac{1}{R}\\sum_{r=1}^{R}\\left\\langle\\xi_{r}\\right|\\cdots\\left|\\xi_{r}\\right\\rangle . \\] Within the user interface, the number of independent random vectors is specified by the parameter <code>num_random</code>, which must be large enough to ensure a well-estimated trace. The associated error scales as \\(1/\\sqrt{R\\,D}\\), and thus requires very few random vectors if the simulated system is very large<sup>2</sup>. On top of this averaging, if \\(\\mathcal{H}\\) has some random component (e.g., by hosting disorder or featuring randomly twisted boundaries), it is often the case that the results need to be averaged over an ensemble of random Hamiltonians. Such averaging is also done inside  <code>KITEx</code> and the number of random configurations is specified by user with the parameter <code>num_disorder</code>."},{"location":"documentation/optimization/#diagonal-matrix-elements","title":"Diagonal Matrix Elements","text":"This class of target functions includes local observables such as the local density of states (LDoS) and the \\(\\mathbf{k}\\)-space spectral function (for ARPES's response), as well as the time-evolution of Gaussian wave-packets. Note that <code>num_random</code> is no longer a relevant parameter for these target functions. In both classes, the core of the method is to expand the functions \\(F_{j}\\) as a truncated Chebyshev series of \\(\\mathcal{H}\\), which allows one to write  \\[ \\mathcal{Q}\\left(\\left\\{ \\lambda_{i}^{j}\\right\\} \\right)\\!=\\!\\begin{cases} \\sum_{n_{1}=0}^{M-1}\\!\\cdots\\!\\sum_{n_{N}=0}^{M-1}G_{1}\\!\\left(\\left\\{ \\lambda_{i}^{1}\\right\\};n_1\\right)\\cdots G_{N}\\!\\left(\\left\\{ \\lambda_{i}^{N}\\right\\};n_N\\right)\\,\\,\\text{Tr}\\left[T_{n_{1}}\\!\\left(\\mathcal{H}\\right)\\mathcal{O}_{1}\\cdots\\mathcal{O}_{N}T_{n_{N}}\\!\\left(\\mathcal{H}\\right)\\right]\\\\ \\sum_{n_{1}=0}^{M-1}\\!\\cdots\\!\\sum_{n_{N}=0}^{M-1}G_{1}\\!\\left(\\left\\{ \\lambda_{i}^{1}\\right\\};n_1\\right)\\cdots G_{N}\\!\\left(\\left\\{ \\lambda_{i}^{N}\\right\\};n_N\\right)\\left\\langle\\Psi\\right|T_{n_{1}}\\!\\left(\\mathcal{H}\\right)\\mathcal{O}_{1}\\cdots\\mathcal{O}_{N}T_{n_{N}}\\!\\left(\\mathcal{H}\\right)\\left|\\Psi\\right\\rangle \\end{cases}\\,\\,, \\] where \\(T_{n}(x)\\) are Chebyshev polynomials of the \\(1^{\\text{st}}\\)-kind and \\(G_{j}\\) are the expansion coefficients of \\(F_{j}\\). The advantage gained by using the Chebyshev expansion is that both \\(\\text{Tr}\\left[\\cdots\\right]\\) and \\(\\left\\langle\\Psi\\right|\\cdots \\left|\\Psi\\right\\rangle\\) can be evaluated recursively using only matrix-vector operations<sup>1</sup>. For all observables implemented in KITE, the functions \\(F_{j}\\) are of three types:  <ol> <li>Single-Parameter Dirac-\\(\\delta\\) Functions.\u2014\\(F_{j}(\\lambda_{1}^{j};\\mathcal{H})\\to\\delta\\left(\\lambda-\\mathcal{H}\\right)\\)</li> <li>Broadened Single-Particle Green's Functions.\u2014\\(F_{j}(\\lambda_{1}^{j},\\lambda_{2}^{j};\\mathcal{H})\\to\\left[\\lambda+i\\eta-\\mathcal{H}\\right]^{-1}\\)</li> <li>Quantum Time-Evolution Operators.\u2014\\(F_{j}\\left(\\lambda_{1}^{j},\\mathcal{H}\\right)\\to\\exp\\left(\\frac{i\\,t\\,\\mathcal{H}}{\\hbar}\\right)\\)</li> </ol> <p>For these functions, analytical forms of the Chebyshev expansion coefficients are known<sup>2</sup><sup>3</sup><sup>4</sup><sup>5</sup><sup>6</sup><sup>7</sup> and used in KITE. In the user interface, the truncation order \\(M\\) is specified by the parameter <code>num_moments</code>, and always impacts the validity of the expanded results. Nevertheless, its precise effect depends crucially on the specific case, as shown in Fig. 1 below. We will now discuss three common cases. </p>"},{"location":"documentation/optimization/#dirac-delta-function","title":"Dirac-delta Function","text":"<p>An order-\\(M\\) expansion (regularized by the Jackson kernel) produces a Gaussian approximation of \\(\\delta(\\lambda\\!-\\!\\mathcal{H})\\) endowed by a width \\(\\sigma_{\\lambda}\\!\\approx\\!\\delta \\varepsilon\\,\\pi/M\\) in \\(\\lambda\\)<sup>2</sup><sup>7</sup>.  The choice of \\(M\\) then fixes the effective spectral width, \\(\\sigma_{\\lambda}\\), which must be sufficiently narrow to accurately describe all relevant features of the calculated property.  However, if \\(\\sigma_{\\lambda}\\) becomes too narrow (\\(M\\) too high), the discrete eigenvalues of the SPH are well-resolved and the obtained data suffers from large (finite-size) fluctuations. For information on other available kernels see Weisse et al.<sup>2</sup>.</p> <p>Rule of Thumb</p> <p>If \\(\\Delta\\varepsilon\\) is the mean-level spacing of the simulated system, then \\(M\\) must be kept smaller than \\(\\frac{\\pi\\,\\delta\\varepsilon}{\\Delta\\varepsilon}\\) in order to avoid resolving individual energy levels. Simultaneously, for obtaining high-resolution results, the artificial broadening must remain much smaller than the lattice bandwidth.</p>"},{"location":"documentation/optimization/#single-particle-greens-functions","title":"Single-Particle Green's Functions","text":"<p>No kernel is required for lattice Green's functions <sup>3</sup><sup>4</sup>. Note that these functions must be broadened by a finite \\(\\eta\\) due to the discrete nature of the energy spectrum of finite systems. An exact spectral decomposition of broadened lattice Green's functions exists and is the basis of the Chebyshev polynomial Green's function method <sup>3</sup> implemented in KITE. Provided \\(\\eta\\) exceeds the spacing between eigenvalues of the SPH, the truncation order may be arbitrarily increased, and convergence is achieved when the data ceases to depend on M. </p> <p>Rule of Thumb</p> <p>Since the energy resolution is fixed by \\(\\eta\\), the number of polynomials must be larger enough to resolve such a broadening. As shown below in Fig. 1(b), an apt rule of thumb is to have \\(M \\gtrsim 10*\\delta \\varepsilon / \\eta\\).</p>"},{"location":"documentation/optimization/#quantum-time-evolution-operators","title":"Quantum Time-Evolution Operators","text":"<p>In time evolution problems, Chebyshev truncation errors propagate and limit the computation accuracy after some finite time has elapsed.  In Fig. 1(c), it is demonstrated that the time evolution operator is converged as long as \\(t\\!\\lesssim\\!\\hbar\\,M/\\delta\\varepsilon\\).</p> <p>Rule of Thumb</p> <p>A safe empirical rule of thumb (used in Santos Pires et al.<sup>6</sup>) is to have \\(M\\!\\gtrsim\\!8\\,\\delta\\varepsilon\\,\\hbar^{-1}t_{\\text{max}}\\!\\!\\), where \\(t\\!&lt;\\!t_{\\text{max}}\\) is the length of the time-interval intended for the evolution.</p> <p>For some target functions, the output of <code>KITEx</code> will span energy and spatial coordinates (as is the case with the LDoS or the spectral function). Note that some response functions (such as the transverse conductivity) will reflect the properties of both the Fermi surface and the Fermi sea of occupied states, and therefore require the raw output of KITE to be numerically integrated over energy. This integration procedure is always done at the post-processing level by <code>KITE-tools</code>.</p> <p>Post-Processing Integration</p> <p>For target functions that require energy integrations, a key parameter is the number of energy points for which the integrand is evaluated. In order to adjust it at the post-processing level, the user can use the <code>-E</code> flag of the <code>KITE-tools</code> executable.</p> <p> Figure 1: Convergence of the Chebyshev series for (a) a Dirac-\\(\\delta\\) function, (b) a single-particle Green's function (real part as inset), and (c)  the time-evolution operator at two different energies (top: 0.5 and bottom: 0.8). </p> <ol> <li> <p>KITE: high-performance accurate modelling of electronic structure and response functions of large molecules, disordered crystals and heterostructures, S. M. Jo\u00e3o, M. An\u0111elkovi\u0107, L. Covaci, T. G. Rappoport, Jo\u00e3o M. Viana Parente Lopes, and A. Ferreira, R. Soc. open sci. 7, 191809 (2020).\u00a0\u21a9\u21a9</p> </li> <li> <p>Kernel polynomial method, Alexander Wei\u00dfe, Gerhard Wellein, Andreas Alvermann, and Holger Fehske. Rev. Mod. Phys. 78, 275 (2006).\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Critical delocalization of chiral zero energy modes in graphene, A. Ferreira and E. Mucciolo, Phys. Rev. Lett. 115, 106601 (2015).\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Numerical evaluation of Green's functions based on the Chebyshev expansion, A. Braun and P. Schmitteckert, Phys. Rev. B 90, 165112 (2014).\u00a0\u21a9\u21a9</p> </li> <li> <p>An accurate and efficient scheme for propagating the time dependent Schr\u00f6dinger equation, H. Tal-Ezer and R. Kosloff, J. Chem. Phys. 81, 3967-3971 (1984).\u00a0\u21a9</p> </li> <li> <p>Landauer transport as a quasisteady state on finite chains under unitary quantum dynamics, J. P. Santos Pires, B. Amorim, and J. M. Viana Parente Lopes, Phys. Rev. B 101, 104203 (2020).\u00a0\u21a9\u21a9</p> </li> <li> <p>Spectral functions of one-dimensional systems with correlated disorder, N. A. Khan, J. M. Viana Parente Lopes, J. P. Santos Pires, J. M. B. Lopes dos Santos, J. Phys.: Condens. Matt. 31, 175501 (2019).\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"documentation/postprocessing/","title":"5. Post-processing","text":"<p>As discussed previously, KITEx typically calculates the Chebyshev moments of a user-specified spectral calculation and stores them in the same HDF file that was generated by the configuration script. These moments are used by the post-processing tool named KITE-tools  to reconstruct the desired physical quantities, such as the density of states or the optical conductivity. Some special target functions are computed 'on the fly', such as the single-shot DC conductivity, and thus require no post-processing. </p> <p>In a basic setup, the Python configuration script specifies the post-processing parameters (e.g., number of energy points), which are exported to the HDF file with other settings. Here, the HDF file containing the Chebyshev moments computed by KITEx works as an input to KITE-tools, which retrieves the post-processing parameters and the Chebyshev moments from the HDF file.  This data is used to calculate the desired quantities and export them to data files. If a parameter is not specified, a default value is applied.</p> <p>However, many of these quantities depend on a set of physical parameters (such as temperature, chemical potential, etc.) that are not necessary for the calculation of Chebyshev moments. Therefore, the user can modify them to quickly recalculate quantities with KITE-tools, without needing to run KITEx again. For example, if the user wants to obtain the optical conductivity as a function of the frequency for several values of chemical potential/temperature, the Chebyshev moments (computed once by KITEx) can be used by KITE-tools to quickly obtain the optical conductivity curves for the different parameter choices.</p>"},{"location":"documentation/postprocessing/#using-the-post-processing","title":"Using the post-processing","text":"<p>For this purpose, the user has the flexibility to override the parameters from the Python script by specifying them in the command line interface. Let us consider the example <code>dos_optcond_gaussian_disorder.py</code>: with the following setting:</p> <pre><code>./build/KITE-tools optcond_gaussian_disorder-output.h5 --CondOpt -F 1.2 -O 0 10 1000 -N optcond1.2.dat\n</code></pre> <p>KITE-tools will calculate the optical conductivity with a Fermi energy specified by the option <code>-F 1.2</code> (in units specified in the configuration file). The option <code>-O</code> sets the frequency interval between <code>0</code>and <code>10</code> (in the same units) and the total number of frequency points (<code>1000</code>). These options will be used to recalculate the optical conductivity even if the original configuration file presents different values.  The option <code>-N</code> defines the name of the output file.</p> <p>We can modify the Fermi energy and produce a different optical conductivities without recalculating the Chebyshev moments:  </p> <p><pre><code>./build/KITE-tools optcond_gaussian_disorder-output.h5 --CondOpt -F 0.5 -O 0 10 1000 -N optcond0.5.dat\n</code></pre> We can now compare the real component of two different optical conductivities  </p> Comparison between the real components of the optical conductivity of disordered graphene for two Fermi energies. <p>The same strategy can be used to calculate the optical conductivity for different temperatures.</p> <p>Info</p> <p>For a more detailed list of possible commands/options for KITE-tools, we strongly recommend you look at the API.</p>"},{"location":"documentation/postprocessing/#other-cases-bespoke-post-processing","title":"Other cases: bespoke post-processing","text":"<p>Some functionalities do not require post-processing or use bespoke post-processing tools that are not included in KITE-tools.  For example, the single-shot longitudinal conductivity functionality <code>singleshot_conductivity_dc</code> does not  store Chebyshev moments in the HDF file, rather it requests KITEx to directly calculate the DC conductivity for specified values of the Fermi energy. </p> <p>To extract the calculated DC conductivity, we can use a Python script located in the <code>tools</code> directory:  <code>process_single_shot.py</code>, using</p> <pre><code>./tools/process_single_shot.py outputfile_name_here.h5 \n</code></pre> <p>In the same <code>tools</code> directory, users can find another script which plots the output of a spectral function (ARPES) calculation.</p> <p>Processing the output of <code>singleshot_conductivity_dc</code></p> <p><code>singleshot_conductivity_dc()</code> works differently from the other target functions in that it just requires a single run with KITEx. As such, the prost-processing with KITE-tools is not required, and instead, the requested single-shot values of the DC conductivity can be retrieved directly from the HDF file once KITEx has run. You can extract the results from the HDF file as explained in the tutorial, with <code>\"output.h5\"</code> the name of the HDF file:</p> <p><pre><code>    import numpy as np\n    from h5py import File\n    condDC = File(\"output.h5\", \"r+\")['Calculation']['singleshot_conductivity_dc']['SingleShot']\n    np.savetxt(\"condDC.dat\",condDC)                \n</code></pre> Alternatively, you can simply use the Python script ('process_single_shot.py') in the <code>kite/tools/</code>-directory.</p>"},{"location":"documentation/settings/","title":"3. Settings","text":"<p>KITE uses the classes <code>kite.Configuration</code> and <code>kite.Calculation</code> to define the calculation settings.</p> <p>This is what a typical <code>kite.Configuration</code> object (for a 2D lattice) looks like:</p> <p><pre><code>nx = ny = 2\nlx = ly = 128\nmode = 'periodic'\nconfiguration = kite.Configuration(\n  divisions=[nx, ny],\n  length=[lx, ly],\n  boundaries=[mode, mode],\n  is_complex=False,\n  precision=1 \n)\n</code></pre> Below, we explain each of the arguments in the <code>kite.Configuration</code> object.</p> <p>Info</p> <p>The current syntax assumes that the user will simulate a 2D or 3D system as a default. However, 1D lattices can be easily constructed by simulating a strip geometry with open boundary conditions in the transverse (y) direction and <code>ly, ny = 1</code>.</p>"},{"location":"documentation/settings/#divisions","title":"Divisions","text":"The <code>divisions</code> is an integer number that defines the number of decomposition parts in each spatial direction.   KITEx implements an efficient domain decomposition technique to divide the lattice into various partitions that are computed in parallel. KITEx  decomposition algorithms are optimized at the design level to deliver optimal multithreading scaling. Their usage for large-scale simulations is highly recommended. To activate this feature, set a number of decomposition parts larger than one, i.e. <code>nx * ny &gt; 1</code> (2D) or <code>nx * ny * nz &gt; 1</code> (3D). <p>Warning</p> <p>The product <code>nx * ny (* nz)</code> equals the number of threads used by KITEx and thus must not exceed the number of available cores in the compute node.</p>"},{"location":"documentation/settings/#length","title":"Length","text":"<p>The <code>length</code> is an integer number of unit cells along the direction of lattice vectors (for example, <code>lx, ly, lz = 256, 256, 256</code>).    The lateral size of the decomposed parts are given by <code>lx/nx</code>, <code>ly/ny</code> and  <code>lz/nz</code>.</p> <p>Warning</p> <p>The lateral sizes <code>lx/nx</code>, <code>ly/ny</code>, <code>lz/nz</code> must be integers.</p> <p>Note that when using a 2D lattice, only <code>lx, ly, nx, ny</code> are needed.</p>"},{"location":"documentation/settings/#boundaries","title":"Boundaries","text":"<p>KITE's default boundary conditions (BCs) are: periodic, open, and twisted. Moreover, a \"random BCs\" option is available, whereby statistical averages over ensembles of random vectors (or disorder configurations) are accelerated via the use of random twist angles drawn from a uniform distribution. This special option is particularly useful to simulate the infinite-size \u201cbulk\", since it efficiently eliminates finite size effects.  </p> <p>The <code>boundaries</code> is a string.  Use <code>'periodic'</code> for periodic BCs, <code>'open'</code> for open BCs, <code>'twisted'</code> for twisted BCs and <code>'random'</code> for random BCs.  In all cases, the system has the geometry of the unit cell, which is replicated <code>lx, ly, lz</code> times in the directions of the unit vectors.  If twisted boundary conditions are used, the twist <code>angles</code> must be provided in radians.</p> <p>Info</p> <p>Different BCs can be used along the different directions.  For example, impose open BCs along one spatial direction to build ribbons in 2D and slabs in 3D. </p>"},{"location":"documentation/settings/#twisted-bc","title":"Twisted BC","text":"<p>For twisted BCs, the twist phase angles need to be specified by the user. This is done by means of an extra argument <code>' angles=[phi_x,phi_y,phi_z]'</code> where <code>'phi_{x,y,z} \\in [0, 2*M_PI]'</code>. The syntax is simple. For example, for a twist angle of pi/2.0 along both lattice directions in a 2D system, we can use: </p> <pre><code>nx = ny = 2\nlx = ly = 128\nmode = 'twisted'\ntwsx = twsy = np.pi/2.0 \n\nconfiguration = kite.Configuration(\n  divisions=[nx, ny],\n  length=[lx, ly],\n  boundaries=[mode, mode],\n  angles = [twsx,twsy]\n  is_complex=False,\n  precision=1 \n)\n</code></pre>"},{"location":"documentation/settings/#random-bc","title":"Random BC","text":"<p>Random BCs are defined using <code>mode = 'random'</code>. No extra arguments are required, but this option implicitly assumes that many random vectors (and/or disorder configurations) will be used  (see Sec. Calculation). For a single system realization, this option is equivalent to a mere twisted-BC simulation with randomly chosen twist-angles along <code>x, y</code> and <code>z</code> lattice directions.</p>"},{"location":"documentation/settings/#complex","title":"Complex","text":"The <code>is_complex</code> is a boolean value.   For optimization purposes, KITEx only considers and stores complex data with the setting <code>is_complex=True</code> activated.   <code>is_complex=False</code> should be used for real symmetric Hamiltonians."},{"location":"documentation/settings/#precision","title":"Precision","text":"The <code>precision</code> is an integer identifier for the used data type.   KITEx allows users to define the precision of the calculation.   Use <code>0</code> for float, <code>1</code> for double, and <code>2</code> for long double."},{"location":"documentation/settings/#spectrum-range","title":"Spectrum Range","text":"<p>The optional <code>spectrum_range</code> is an array of real values.   By default, KITE executes an automated rescaling of the Hamiltonian (Sec. Documentation).   Advanced users are encouraged to override this feature and specify the energy interval manually using <code>spectrum_range=[Emin,Emax]</code>, where <code>Emin, Emax</code> are the minimum, maximum energy eigenvalues.</p> <p>Lower/upper bounds should be used if exact energy eigenvalues of the lattice model are unknown (e.g. due to the presence of a disorder landscape); see Sec. Disorder for more information. </p> <p>To manually set the energy spectrum limits, it is necessary to add an extra parameter (<code>spectrum_range</code>) to the <code>kite.Configuration</code> class:</p> <pre><code>configuration = kite.Configuration(\n    divisions=[nx, ny],\n    length=[lx, ly],\n    boundaries=[\"periodic\", \"periodic\"],\n    is_complex=False,\n    precision=1,\n    spectrum_range=[-10, 10]\n)\n</code></pre>"},{"location":"documentation/tb_model/","title":"2. Lattice","text":"<p>The aim of the current section is to help us gain familiarity with the lattice model of KITE.  Thus, we begin by constructing a periodic <code>pb.Lattice</code> using Pybinding and calculating its band structure using <code>pb.Solver</code> (also from Pybinding).  In the following sections, we will learn how to use KITEx to significantly scale up the simulations and introduce modifications to the lattice model.</p> <p>For efficiency, the default options of KITE's core code (KITEx) assume that the lattice model has a certain degree of interconnectivity or hopping range.  Specifically, the default is that the tight-binding Hamiltonian has non-zero matrix elements between orbitals that belong to unit cells  that are separated by at most 2 lattice spacings along a given direction (for example, in a simple single-orbital 1D chain this would allow defining models with up to second-nearest neighbors). To relax this constraint and thus be able to simulate more complex lattice models, users must adjust the NGHOSTS parameter in <code>kite/Src/Generic.hpp</code> and recompile KITEx, otherwise an error message is output and the KITE program exits.</p> <p>Info</p> <p>If you are familiar with Pybinding, you can go directly to the next tutorial page.</p> <p>Note</p> <p>The python script that generates KITE's input file requires a few packages that can be included with the following aliases</p> <pre><code>import kite\nimport pybinding as pb\nimport numpy as np\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"documentation/tb_model/#constructing-a-pblattice","title":"Constructing a <code>pb.Lattice</code>","text":"<p>The <code>pb.Lattice</code> class from Pybinding carries the information about the TB model. This includes:</p> <ul> <li>Crystal structure (lattice unit cell and basis)</li> <li>Onsite energies</li> <li>Hopping parameters</li> </ul> <p>Pybinding also provides additional functionalities based on the above real-space information. For example, it can prove the reciprocal vectors and the Brillouin zone.</p>"},{"location":"documentation/tb_model/#defining-the-unit-cell","title":"Defining the unit cell","text":"<p>As a simple example, let us construct a square lattice with a single orbital per unit cell. The following syntax can be used to define the primitive lattice vectors:</p> <pre><code>a1 = np.array([1, 0]) # [nm] defines the first lattice vector\na2 = np.array([0, 1]) # [nm] defines the second lattice vector\n\nlat = pb.Lattice(a1=a1, a2=a2) # defines a lattice object\n</code></pre>"},{"location":"documentation/tb_model/#adding-lattice-sites","title":"Adding lattice sites","text":"<p>We can then add the desired lattice sites/orbitals inside the unit cell (the same syntax can be used to add different orbitals in a given position or more sites in different sublattices):</p> <pre><code>onsite = 0 # onsite potential\nlat.add_sublattices(\n    # generates a lattice site (sublattice) with a tuple\n    # (name, position, and onsite potential)\n    ('A', [0, 0], onsite)\n)\n</code></pre>"},{"location":"documentation/tb_model/#adding-hoppings","title":"Adding hoppings","text":"<p>By default, the main unit cell has the index <code>[n1,n2] = [0, 0]</code>. The hoppings between neighboring sites can be added with the simple syntax:</p> <pre><code>lat.add_hoppings(\n    # generated a hopping between lattice sites with a tuple\n    # (relative unit cell index, site from, site to, hopping energy)\n    ([1, 0], 'A', 'A', - 1 ),\n    ([0, 1], 'A', 'A', - 1 )\n)\n</code></pre> <p>Here, the relative indices <code>n1,n2</code> represent the number of integer steps - in units of the primitive lattice vectors - needed to reach a neighboring cell starting from the origin.</p> <p>If the lattice has more than one sublattice, the hoppings can connect sites in the same unit cell.</p> <p>Note</p> <p>When adding the hopping <code>(n, m)</code> between sites <code>n</code> and <code>m</code>, the conjugate hopping term <code>(m, n)</code> is added automatically. Pybinding does not allow the user to add them manually.</p>"},{"location":"documentation/tb_model/#visualization","title":"Visualization","text":"<p>Now we can plot the <code>pb.lattice</code> and visualize the Brillouin zone:</p> <pre><code>lat.plot()\nplt.show()\n\nlat.plot_brillouin_zone()\nplt.show()\n</code></pre> The visualization of the lattice and its Brillouin zone. <p>Examples</p> <p>For a crystal with two atoms per unit cell, look in the Examples section. For other examples and pre-defined lattices, consult the Pybinding documentation.</p>"},{"location":"documentation/tb_model/#using-pybindings-solver","title":"Using Pybinding's solver","text":"<p>Pybinding has built-in solvers for</p> <ul> <li>LAPACK (exact diagonalization)</li> <li>ARPACK (targeted diagonalization of sparse matrices)</li> </ul> <p>To use any of these solvers, we need to first construct a model.</p>"},{"location":"documentation/tb_model/#building-a-pbmodel","title":"Building a <code>pb.Model</code>","text":"<p>The <code>pb.Model</code> class contains all the information of the structure we want to use in our calculation. This structure can be significantly larger than the unit cell (stored in the <code>pb.Lattice</code> class). It can also have specific geometries and other possible modifications of the original lattice.  Here, we will double the unit cell in both directions in the <code>pb.Model</code> and add periodic boundary conditions: <pre><code>model = pb.Model(\n    lat,  # pb.Lattice, uses the previously defined unit-cell\n    pb.primitive(2, 2),  # doubles the unit-cell in both directions\n    pb.translational_symmetry(a1=2, a2=2)  # periodic boundary conditions with period '2'\n)\n</code></pre> We can visualise this <code>pb.Model</code> with <pre><code>model.plot()\nplt.show()\n</code></pre></p> The visualization of the model."},{"location":"documentation/tb_model/#defining-a-pbsolver","title":"Defining a <code>pb.Solver</code>","text":"<p>The <code>pb.Solver</code> class takes a <code>pb.Model</code> class as input and prepares the system to perform a numerical calculation. We will use the LAPACK solver: <pre><code>solver = pb.solver.lapack(\n    model  # pb.Model, use the previously defined system\n)\n</code></pre></p>"},{"location":"documentation/tb_model/#band-structure-calculation","title":"Band structure calculation","text":"<p>As an example, the band structure is calculated using the <code>pb.Solver</code> defined above.</p> <p>First, for a two-dimensional plot, we define a path in the reciprocal space that connects the high symmetry points. Using the <code>pb.Lattice</code> built-in method, the high-symmetry points for the corners of a path can be found easily: <pre><code>bz = lat.brillouin_zone()\ngamma = np.array([0, 0]) \nx = (bz[1] + bz[2]) / 2\ns = bz[2]\n</code></pre></p> <p>We can then pass these corners to the <code>pb.Solver</code> and visualize the result <pre><code>bands = solver.calc_bands(gamma, x, s, gamma, step=0.01)\nbands.plot(point_labels=[r\"$\\Gamma$\", \"X\", \"S\", r\"$\\Gamma$\"])\nplt.show()\n\nlat.plot_brillouin_zone(decorate=False)\nbands.k_path.plot(point_labels=[r\"$\\Gamma$\", \"X\", \"S\", r\"$\\Gamma$\"])\nplt.show()\n</code></pre></p> The visualization of the band structure and its path in the reciprocal space. <p>For more info about Pybinding's capabilities, look at its tutorial or API guide.</p> <p>Summary of the code from this section</p> <pre><code>import kite\nimport pybinding as pb\nimport numpy as np\nimport matplotlib.pyplot as plt\n\na1 = np.array([1, 0]) # [nm] define the first lattice vector\na2 = np.array([0, 1]) # [nm] define the second lattice vector\n\nlat = pb.Lattice(a1=a1, a2=a2) # define a lattice object\n\n\nonsite = 0 # onsite potential\nlat.add_sublattices(\n    # make a lattice site (sublattice) with a tuple\n    # (name, position, and onsite potential)\n    ('A', [0, 0], onsite)\n)\n\nlat.add_hoppings(\n    # make an hopping between lattice site with a tuple\n    # (relative unit cell index, site from, site to, hopping energy)\n([1, 0], 'A', 'A', - 1 ),\n([0, 1], 'A', 'A', - 1 )\n)\n\nmodel = pb.Model(\n    lat,  # pb.Lattice, use the previously defined unit-cell\n    pb.primitive(2, 2),  # double the unit-cell in both directions\n    pb.translational_symmetry(a1=2, a2=2)  # periodic boundary conditions with period '2'\n)\n\nsolver = pb.solver.lapack(\n    model  # pb.Model, use the previously defined system\n)\n\nbz = lat.brillouin_zone()\ngamma = np.array([0, 0]) \nx = (bz[1] + bz[2]) / 2\ns = bz[2]\n\nbands = solver.calc_bands(gamma, x, s, gamma, step=0.01)\nbands.plot(point_labels=[r\"$\\Gamma$\", \"X\", \"S\", r\"$\\Gamma$\"])\nplt.show()\n\nlat.plot_brillouin_zone(decorate=False)\nbands.k_path.plot(point_labels=[r\"$\\Gamma$\", \"X\", \"S\", r\"$\\Gamma$\"])\nplt.show()\n</code></pre>"},{"location":"documentation/workflow/","title":"1. Workflow","text":"<p>KITE has three different layers:</p> <ul> <li>User interface (Python) </li> <li>Main program (C++)</li> <li>Post-processing tool (C++)</li> </ul> <p>The tight-binding (TB) model is defined on a Python interface based on Pybinding. The TB parameterization benefits from a number of KITE-specific advanced features, including disorder patterns and magnetic-field modifications. The KITE model - which includes the desired target function calculations, such as the DoS - is exported to a HDF5-file, together with the calculation settings (i.e. system size, boundary conditions, parallelization options, etc.). This file is then given as an input to the main program (KITEx). The input and output for the main program are written to the same HDF5 file. The complete workflow is summarized in the figure below.</p> The different components of KITE and its workflow."},{"location":"documentation/workflow/#steps","title":"Steps","text":"<ol> <li>Start by building a <code>pb.Lattice</code> that describes a regular tight-binding model (Section 2)</li> <li>Add optional terms to the TB Hamiltonian, including disorder patterns and a magnetic field (covered in Section 6 and 7)</li> <li>Specify the calculations settings (Section 3) and the desired target functions to be computed (Section 4)</li> <li>Export your KITE model to the HDF5 file and run KITEx (Section 4)</li> <li>Post-process the data using the post-processing tools KITE-tools and visualise the data (Section 5)</li> </ol> <p>Tip</p> <p>It is possible to use a simple python script for the whole workflow.</p>"},{"location":"documentation/examples/","title":"About the examples","text":"<p>This set of examples is designed to be illustrative but not exhaustive. They do not cover all scripts that can be found in the KITE examples folder,  but they give an in-depth perspective on how to build a script with a given functionality and analyse the results.</p> <p>The online documentation provided here focuses on well-studied 2D materials to allow easy comparison with recent literature. There is also a broad range of examples in KITE's repository folder which illustrate KITE's functionalities across a variety of tight-binding systems, from simple square lattices to 3D lattice models displaying Weyl semi-metallic phases.  </p>"},{"location":"documentation/examples/#running-all-the-examples","title":"Running all the examples","text":"<p>To run all the examples at once, run the <code>run_all_examples.py</code> script from the <code>kite/examples/</code>-folder with</p> <pre><code>python -m run_all_examples.py\n</code></pre>"},{"location":"documentation/examples/graphene/","title":"Graphene","text":""},{"location":"documentation/examples/graphene/#the-tb-model-for-graphene","title":"The TB-model for Graphene","text":"<p>The electronic structure of graphene is well-described by a simple tight-binding model that only uses one \\(p_z\\) orbital in a hexagonal unit cell with two equivalent carbon atoms. These atoms are located on the different sublattices, A and B, and don't have an on-site energy term.</p> <p>Although this model is relatively simple, it is used often within the literature. The example below uses graphene to show how to construct a lattice with sublattices and perform a basic calculation using KITE. The script for this example can be found here.</p>"},{"location":"documentation/examples/graphene/#lattice","title":"Lattice","text":"<p>We start by building the <code>pb.lattice</code> for graphene:</p> <ul> <li>Define the parameter (\\(t\\) in eV)</li> <li>Define the vectors of the unit-cell (\\(\\vec a_1\\) and \\(\\vec a_2\\) in units of \\(a\\), length of the unit-cell)</li> <li>Create a <code>pb.lattice</code>-object</li> <li>Define the on-site energies</li> <li>Define the hopping parameters<ul> <li>1 normal hopping within the unit cell</li> <li>2 rotated hopping \\(\\pm 2 \\pi/3\\) to neighbouring cells</li> </ul> </li> <li>Return the <code>pb.lattice</code>-object to be used by KITE</li> </ul> <pre><code>def graphene_lattice(onsite=(0, 0)):\n    \"\"\"Return lattice specification for a honeycomb lattice with nearest neighbor hoppings\"\"\"\n\n    # parameters\n    a = 0.24595  # [nm] unit cell length\n    a_cc = 0.142  # [nm] carbon-carbon distance\n    t = 2.8  # eV\n\n    # define lattice vectors\n    a1 = a * np.array([1, 0])\n    a2 = a * np.array([1 / 2, 1 / 2 * np.sqrt(3)])\n\n    # create a lattice with 2 primitive vectors\n    lat = pb.Lattice(a1=a1, a2=a2)\n\n    # add sublattices\n    lat.add_sublattices(\n        # name, position, and onsite potential\n        ('A', [0, -a_cc/2], onsite[0]),\n        ('B', [0,  a_cc/2], onsite[1])\n    )\n\n    # Add hoppings\n    lat.add_hoppings(\n        # inside the main cell, between which atoms, and the value\n        ([0, 0], 'A', 'B', -t),\n        # between neighboring cells, between which atoms, and the value\n        ([1, -1], 'A', 'B', -t),\n        ([0, -1], 'A', 'B', -t)\n    )\n    return lat\n</code></pre> <p>We can visualize this lattice using the following code:</p> <pre><code>lat = graphene_lattice()\nlat.plot()\nplt.show()\n</code></pre> A visualization for the defined lattice of graphene."},{"location":"documentation/examples/graphene/#kitex-calculation","title":"KITEx calculation","text":""},{"location":"documentation/examples/graphene/#settings-and-calculation","title":"Settings and calculation","text":"<p>We can make the <code>kite.Calculation</code> object <pre><code>configuration = kite.Configuration(\n  divisions=[64, 64],\n  length=[512, 512],\n  boundaries=[\"periodic\", \"periodic\"],\n  is_complex=False,\n  precision=1\n)\ncalculation = kite.Calculation(configuration)\ncalculation.dos(\n  num_points=4000,\n  num_moments=256,\n  num_random=256,\n  num_disorder=1\n)\n</code></pre> Set up the <code>kite.config_system</code> as detailed in Sec. Calculation and export the KITE model running <pre><code>python3 script_name_here.py\n</code></pre> which then creates the necessary HDF file. Next, run the KITEx program and the KITE-tools.</p>"},{"location":"documentation/examples/graphene/#visualization","title":"Visualization","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\ndata = np.loadtxt('dos.dat')\nplt.plot(data[:,0], data[:,1])\nplt.show()\n</code></pre> The DOS for graphene."},{"location":"documentation/examples/haldane/","title":"Haldane","text":""},{"location":"documentation/examples/haldane/#the-haldane-model","title":"The Haldane model","text":"<p>The Haldane Hamiltonian is a single-orbital tight-binding model on a honeycomb lattice with a sublattice-staggered on-site potential (orbital mass).  Complex hoppings between next-nearest-neighbor sites produce a staggered magnetic field configuration with vanishing total flux through the unit cell <sup>1</sup>.</p> <p>This model describes a Chern insulator (or a quantum anomalous Hall insulator) because it hosts an integer quantum Hall effect in the absence of any applied external magnetic fields. This characteristic makes Haldane model ideal for illustrating another capability of KITE: the calculation of transverse conductivities reflecting the quantum geometry of wavefunctions <sup>2</sup> <sup>3</sup>.</p> <p>Let us use KITE to compute the dc conductivity tensor of the Haldane model.  The full script for this example can be found here.</p>"},{"location":"documentation/examples/haldane/#lattice","title":"Lattice","text":"<p>Let us begin with the definition of the Hamiltonian for the case of purely imaginary next-nearest-neighbor hoppings:</p> <pre><code>def haldane(onsite=(0, 0), t=1):\n    \"\"\"Return lattice specification for Haldane model\"\"\"\n\n    # parameters\n    a = 0.24595  # [nm] unit cell length\n    a_cc = 0.142  # [nm] carbon-carbon distance\n    t2 = t/10\n\n    # define lattice vectors\n    a1 = a * np.array([1, 0])\n    a2 = a * np.array([1 / 2, 1 / 2 * np.sqrt(3)])\n\n    # create a lattice with 2 primitive vectors\n    lat = pb.Lattice(a1=a1, a2=a2)\n\n    # add sublattices\n    lat.add_sublattices(\n        # name, position, and onsite potential\n        ('A', [0, -a_cc/2], onsite[0]),\n        ('B', [0,  a_cc/2], onsite[1])\n    )\n\n    # Add hoppings\n    lat.add_hoppings(\n        # inside the main cell, between which atoms, and the value\n        ([0,  0], 'A', 'B', -t),\n        # between neighboring cells, between which atoms, and the value\n        ([1, -1], 'A', 'B', -t),\n        ([0, -1], 'A', 'B', -t),\n        ([1, 0], 'A', 'A', -t2 * 1j),\n        ([0, -1], 'A', 'A', -t2 * 1j),\n        ([-1, 1], 'A', 'A', -t2 * 1j),\n        ([1, 0], 'B', 'B', -t2 * -1j),\n        ([0, -1], 'B', 'B', -t2 * -1j),\n        ([-1, 1], 'B', 'B', -t2 * -1j)\n    )\n    return lat\n</code></pre>"},{"location":"documentation/examples/haldane/#kitex-part","title":"KITEx part","text":""},{"location":"documentation/examples/haldane/#settings","title":"Settings","text":"<p>The following explains the steps to calculate the Hall conductivity. The first step is to define <code>kite.configuration</code>, as explained in Settings. For example,</p> <pre><code>configuration = kite.Configuration(\ndivisions=[2, 2],\nlength=[128, 128],\nboundaries=['periodic', 'periodic'],\nis_complex=True,\nprecision=0,\nspectrum_range=[-10, 10]\n)\n</code></pre> <p>Then, we can set <code>kite.calculation</code>. We note that the the post-processing tool uses the energy spectrum limits in the HDF file (<code>[-10,10]</code> in the example above) to perform the integration over the energy of occupied states.</p> <pre><code>calculation.conductivity_dc(num_points=1000,\n                            num_moments=256,\n                            num_random=50,\n                            num_disorder=1,\n                            direction='xy',\n                            temperature=0.05)\n</code></pre>"},{"location":"documentation/examples/haldane/#disorder","title":"Disorder","text":"<p>We can include different types of disorder. For simplicity, we consider on-site uniform disorder distribution with width of <code>0.4</code> and zero average on-site energy (Anderson disorder):</p> <pre><code>disorder = kite.Disorder(lattice)\ndisorder.add_disorder('A', 'Uniform', +0.0, 0.4)\ndisorder.add_disorder('B', 'Uniform', +0.0, 0.4)\n</code></pre>"},{"location":"documentation/examples/haldane/#calculation-and-post-processing","title":"Calculation and post-processing","text":"<p>Export the KITE model to an HDF file (see Sec. Calculation) and run the KITEx program.</p> <p>This is a full spectral calculation where KITEx calculates the coefficients of the Chebyshev expansion, and KITE-tools uses those moments to retrieve the transverse conductivity over the full energy range. Both <code>temperature</code> and <code>num_points</code> are parameters used by KITE-tools, and it is possible to modify them without running KITEx again. This type of calculation typically requires more RAM memory than DOS or single-shot DC conductivity, which imposes limitations to the sizes of the systems (that can still reach large scales with available memory). This has implications for the stochastic trace evaluation (STE) done by KITE, whose relative error typically scales with \\(1/\\sqrt{N_R D}\\)  (here,  \\(N_R\\) is the number of random vectors and \\(D\\) is the total number of sites). The STE errors   can thus be significant, especially at large Chebyshev orders (required to achieve fine energy resolutions). More generally, the relative error of the STE also depends on the lattice model, type of disorder and the calculated quantities. Transverse conductivities have strong fluctuations outside of the topological gap. This tutorial aims to illustrate this issue.</p> <p>Fig. 1 below shows the longitudinal and transverse conductivity for a small lattice of Haldane model in a calculation that took a few minutes on a laptop. KITEx captures the anomalous quantum Hall plateau extremely well, with a relative error of less than 0.1%. But it is also clear that the transverse conductivity presents significantly more fluctuations outside the plateau than the longitudinal conductivity, and we already considered 50 random vectors.  A finer energy resolution can be obtained by running the simulation for larger systems and/or increasing the number of random vectors used in the STE (see below).</p> <p>This figure can be reproduced using KITE-tools while specifying some additional parameters (refer to the post-processing tools documentation if you need more details). To this end, run the following line</p> <pre><code>./build/KITE-tools haldane.h5 --CondDC -F -4 4 1000\n</code></pre> <p>which calculates the <code>xy</code> conductivity of the system specified above for 1000 equidistant Fermi energies in the range <code>[-4, 4]</code>. The result can be plotted by using the brief Python script below. (The computation and visualization of the longitudinal conductivity follows identical steps.)</p>"},{"location":"documentation/examples/haldane/#visualisation","title":"Visualisation","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\ndata = np.loadtxt('condDC.dat')\nplt.plot(data[:,0], data[:,1])\nplt.show()\n</code></pre>  Figure 1 <p>We now focus on strategies to decrease the fluctuations. Depending on the computational resources, one possibility is increasing the system size. It is also possible to increase the number of random vectors. This is illustrated in Fig. 2.</p> Figure 2  <p>Finally, there are other ways of damping the STE fluctuations, e.g. via a simple thermal averaging effect (temperature) or the use of uncorrelated disorder. The use of such strategies depend on the goals of the numerical calculation. In the present case, where we primarily wanted to see the quantum anomalous Hall plateau, we can simply consider a moderate Anderson disorder and work with intermediate temperatures.</p> <p>Example</p> <p>Get more familiar with KITE: tweak the full script for this calculation and play with variations of system size, number of random vectors, disorder and temperature.</p> <ol> <li> <p>F. D. M. Haldane, Phys. Rev. Lett. 61, 2015 (1988) \u21a9</p> </li> <li> <p>J. H. Garc\u00eda, L. Covaci, and T. G. Rappoport, Phys. Rev. Lett. 114, 116602 (2015) (Supplementary material)\u00a0\u21a9</p> </li> <li> <p>S. G. de Castro, J. M. V. P. Lopes, A. Ferreira, and D. A. Bahamon, Phys. Rev. Lett. 132, 076302  (2024) \u21a9</p> </li> </ol>"},{"location":"documentation/examples/optical_conductivity/","title":"Optical Conductivity","text":""},{"location":"documentation/examples/optical_conductivity/#gaussian-disorder","title":"Gaussian disorder","text":"<p>KITE can also calculate the optical conductivity of a given tight-binding model for any desired chemical potential/temperature. To illustrate this capability, here we calculate the optical conductivity of disordered graphene that can be compared qualitatively with previous results<sup>1</sup>.  The full script can be found here.</p>"},{"location":"documentation/examples/optical_conductivity/#lattice","title":"Lattice","text":"<p>Instead of manually defining the lattice, we can use of one the pre-defined lattices from Pybinding:</p> <pre><code>    from pybinding.repository import graphene\n    lattice = graphene.monolayer()\n</code></pre>"},{"location":"documentation/examples/optical_conductivity/#kitex-part","title":"KITEx part","text":""},{"location":"documentation/examples/optical_conductivity/#disorder","title":"Disorder","text":"<p>To illustrate a different type of disorder, we add random on-site energies that follow a Gaussian distribution:</p> <pre><code>    disorder = kite.Disorder(lattice)\n    disorder.add_disorder('B', 'Gaussian', 0.0, 1.5)\n    disorder.add_disorder('A', 'Gaussian', 0.0, 1.5)\n</code></pre> <p>where we define the type of statistical distribution, the sublattices where they are located, the mean value of the distribution and its width (in eV here).</p>"},{"location":"documentation/examples/optical_conductivity/#settings-and-calculation","title":"Settings and calculation","text":"<p>After configuring the system, as presented in the Getting Started tutorial, it is time to set up the calculation:</p> <pre><code>    calculation = kite.Calculation(configuration)\n    calculation.conductivity_optical(num_points=1000, num_disorder=1,\n                     num_random=20, num_moments=512, direction='xx')\n</code></pre> <p>The transverse optical conductivity (<code>xy</code>,<code>xz</code>, etc.) can also be calculated, which can be quite interesting in systems that also present transverse responses (e.g. due to a nontrivial band topology) <sup>3</sup>. However, in this example we focus exclusively on the longitudinal optical conductivity. The other quantities that can be set in the Python script are the same as for the calculation of the density of states: number of energy points used in KITE-tools, Chebyshev moments in the expansions, random vectors and disorder realizations.</p> <p>Export the KITE model and run KITEx as before.</p>"},{"location":"documentation/examples/optical_conductivity/#post-processing-and-visualization","title":"Post-processing and visualization","text":"<p>The post-processing step is similar to that of other examples (see post-processing tools documentation). For example, you may run</p> <pre><code>./build/KITE-tools name_of_IO_file_here.h5 --CondOpt -F 2.5 -T 0.025 -S 0.01 -O 0.1 12 250\n</code></pre> <p>which outputs the complex optical conductivity in a uniform grid with \\(250\\) points covering the frequency range <code>[0.1:12]</code> eV for a Fermi energy of <code>2.5</code> eV and a temperature of  <code>25</code> meV. The requested energy resolution is set to <code>10</code> meV.</p>"},{"location":"documentation/examples/optical_conductivity/#visualization","title":"Visualization","text":"<p>The results of the real and imaginary parts of the optical conductivity presented in the Fig. 1 were obtained on a standard laptop with calculations that took 8 minutes for a system with <code>N=512 x 512</code> units cells  and a total of <code>512 x 512</code> expansion moments (<code>num_moments=512</code>).</p> Figure 1: Frequency dependence of graphene's complex optical conductivity.  <p>For systems sizes of <code>N=1536 x 1536</code> unit cells and two different Gaussian widths, we show \\(\\Re [\\sigma_{xx}(\\omega)]\\) for low frequencies (see Fig. 2). In both figures, one can clearly see the Drude's peak for \\(\\omega\\rightarrow 0\\) and the onset of interband transitions at \\(\\hbar \\omega&gt;2 E_F\\) <sup>2</sup>.</p> Figure 1: Real part of the optical conductivity over a narrower frequency range for two choices of disorder strength as indicated. <p>The complete Python script for this calculation can be found here.</p> <ol> <li> <p>Shengjun Yuan, Rafael Rold\u00e1n, Hans De Raedt, Mikhail I. Katsnelson, Phys. Rev. B 84, 195418 (2011) \u21a9</p> </li> <li> <p>T. Stauber, N. M. R. Peres, A. K. Geim, Phys. Rev. B 78, 085432 (2008) \u21a9</p> </li> <li> <p>S. M. Jo\u00e3o et al, R. Soc. open sci. 7, 191809 (2020) \u21a9</p> </li> </ol>"},{"location":"documentation/examples/phosphorene/","title":"Phosphorene","text":""},{"location":"documentation/examples/phosphorene/#phosphorene","title":"Phosphorene","text":"<p>This is a small tutorial to illustrate the use of KITE to investigate materials with anisotropic electrical conductivity. To this end, we consider a simplified tight-binding model for single layer phosphorene <sup>1</sup>. Even though this model is very simple, it captures the anisotropic band structure of phosphorene, which is Dirac-like in one direction and Schr\u00f6dinger-like in the other direction. This behaviour results in highly anisotropic transport properties <sup>2</sup>.</p> <p>Here, we calculate the longitudinal conductivity (<code>singleshot_conductivity_dc</code>) via the efficient single-shot CPGF algorithm <sup>3</sup> in the vicinity of the band gap. This is a fast numerical calculation that is set to easily run on a standard laptop, which qualitatively reproduces the expected anisotropic conductivity along xx and yy directions.</p> <p>Here, we highlight parts of the Python script. The full script can be retrieved from KITE's Github repository.</p>"},{"location":"documentation/examples/phosphorene/#lattice","title":"Lattice","text":"<p>After the imports that are necessary for KITE, we define the lattice with Pybinding:</p> <pre><code>from numpy import cos, sin, pi\n\ndef monolayer_4band(num_hoppings=4):\n    \"\"\"Monolayer phosphorene lattice using the four-band model\n\n    Parameters\n    ----------\n    num_hoppings : int\n    Number of hopping terms to consider: from t2 to t5.\n    \"\"\"\n    a = 0.222  # nm\n    ax = 0.438  # nm\n    ay = 0.332  # nm\n    theta = 96.79 * (pi / 180)\n    phi = 103.69 * (pi / 180)\n\n    lat = pb.Lattice(a1=[ax, 0], a2=[0, ay])\n\n    h = a * sin(phi - pi / 2)\n    s = 0.5 * ax - a * cos(theta / 2)\n    lat.add_sublattices(('A', [-s/2,        -ay/2, h], 0),\n                       ('B', [ s/2,        -ay/2, 0], 0),\n                       ('C', [-s/2 + ax/2,     0, 0], 0),\n                       ('D', [ s/2 + ax/2,     0, h], 0))\n\n    lat.register_hopping_energies({'t1': -1.22, 't2': 3.665, 't3': -0.205,\n                               't4': -0.105, 't5': -0.055})\n\n    if num_hoppings &lt; 2:\n        raise RuntimeError(\"t1 and t2 must be included\")\n    elif num_hoppings &gt; 5:\n        raise RuntimeError(\"t5 is the last one\")\n\n    if num_hoppings &gt;= 2:\n        lat.add_hoppings(([-1,  0], 'A', 'D', 't1'),\n                         ([-1, -1], 'A', 'D', 't1'),\n                         ([ 0,  0], 'B', 'C', 't1'),\n                         ([ 0, -1], 'B', 'C', 't1'))\n         lat.add_hoppings(([ 0,  0], 'A', 'B', 't2'),\n                         ([ 0,  0], 'C', 'D', 't2'))\n    if num_hoppings &gt;= 3:\n         lat.add_hoppings(([ 0,  0], 'A', 'D', 't3'),\n                          ([ 0, -1], 'A', 'D', 't3'),\n                          ([ 1,  1], 'C', 'B', 't3'),\n                          ([ 1,  0], 'C', 'B', 't3'))\n    if num_hoppings &gt;= 4:\n        lat.add_hoppings(([ 0,  0], 'A', 'C', 't4'),\n                         ([ 0, -1], 'A', 'C', 't4'),\n                         ([-1,  0], 'A', 'C', 't4'),\n                         ([-1, -1], 'A', 'C', 't4'),\n                         ([ 0,  0], 'B', 'D', 't4'),\n                         ([ 0, -1], 'B', 'D', 't4'),\n                         ([-1,  0], 'B', 'D', 't4'),\n                         ([-1, -1], 'B', 'D', 't4'))\n    if num_hoppings &gt;= 5:\n         lat.add_hoppings(([-1,  0], 'A', 'B', 't5'),\n                         ([-1,  0], 'C', 'D', 't5'))\n\n    lat.min_neighbors = 2\n    return lat\n</code></pre> <p>Note that the lattice model given above can be used with different numbers of hoppings. The user can decide the number that is used in the calculation when defining the lattice:</p> <pre><code>lattice=monolayer_4band(num_hoppings=4)\n</code></pre>"},{"location":"documentation/examples/phosphorene/#kitex-part","title":"KITEx part","text":""},{"location":"documentation/examples/phosphorene/#settings","title":"Settings","text":"<p>To use the large-scale single-shot algorithm for direct evaluation of zero-temperature DC conductivities, the resolvent operator requires a nonzero broadening (resolution) parameter <code>eta</code>, which is given in the specified units (eV in the example above). As this type of calculation is energy-dependent, it is also necessary to provide a list of desired energy points to the calculation object. In the single-shot calculations, the computational time scales linearly with the energy points. For this example, we consider a small number of points and the energy range is set in the vicinity of the band gap.</p> <p>The number of points and the list of energy points can be created when calling the calculation, as illustrated here:</p> <pre><code>calculation = kite.Calculation(configuration)\nnpoints = 25\nepoints = [(1.0 / npoints * i) * 3.5  for i in range(npoints)]\ncalculation.singleshot_conductivity_dc(epoints,\n                                       num_moments=512,\n                                       num_random=5,\n                                       num_disorder=1,\n                                       direction='xx',\n                                       eta=0.02)\n</code></pre> <p>Now it is time to save the configuration in a hdf file:</p> <pre><code>kite.config_system(lattice, configuration, calculation, filename='phxx.h5')\n</code></pre> <p>Export the KITE model to an HDF file:</p> <pre><code>python3 script_name_here.py\n</code></pre>"},{"location":"documentation/examples/phosphorene/#calculation","title":"Calculation","text":"<p>Run the KITEx program.</p>"},{"location":"documentation/examples/phosphorene/#visualization","title":"Visualization","text":"<p>After running KITEx, no post-processing is required for the single-shot conductivity calculation. The result can be extracted and plotted with the following script:</p> <pre><code>import h5py\nimport matplotlib.pyplot as plt\n\nfile_name = 'phxx.h5'\n\nnum_points = 25\nenergy = [(1.0 / num_points * i) * 3.5 for i in range(num_points)]\n\nfile_input = h5py.File(file_name, 'r+')\nsingle_shot = file_input['Calculation']['singleshot_conductivity_dc']['SingleShot']\ncond = single_shot[:, 3]\n\nplt.plot(energy, cond, 'o-')\nplt.xlabel('$E$ [eV]')\nplt.ylabel(r'$\\sigma$ [$4e^2 / h$]')\nplt.title('Phosphorene')\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Alternatively, the single-shot post-processing python tool in the <code>tools</code> directory can be used to produce the data in a more streamlined fashion (see Sec. Post-Processing). </p> Figure 1: Longitudinal DC conductivity as a function of Fermi energy for a small system computed with the single-shot CPGF algorithm. <p>It is not possible to request the same type of calculation (target function) in a single call. In this case, we want to calculate the conductivity in xx and yy directions where the type of the calculation is the same, which means we need another HDF file for yy conductivity.</p> <p>Let's repeat the procedure for another direction (one may also use the streamlined approach of the example on the KITE repository):</p> <pre><code>    calculation.singleshot_conductivity_dc(epoints,\n                                           num_moments=512,\n                                           num_random=5,\n                                           num_disorder=1,\n                                           direction='xx',\n                                           eta=0.02)\n    kite.config_system(lattice, configuration, calculation, filename='phyy.h5')\n</code></pre> <p>The result of this fast calculation can be seen in Fig. 2 below, for <code>lx=ly=512</code>. To gain confidence with using KITE, we suggest modifying parameters like <code>eta</code> and <code>num_random</code>.</p> Figure 2: Longitudinal and transverse components of the DC conductivity tensor and the DoS as a function of Fermi energy. <p>In Fig. 3, we repeat the calculation for 300 energy points and 10 random vectors with a large energy window.</p> Figure 2: Similar to Fig. 1, but over a larger energy window and with lower statistical fluctuations. <ol> <li> <p>Alexander N. Rudenko, Mikhail I. Katsnelson, Phys. Rev. B 89, 201408 (2014).\u00a0\u21a9</p> </li> <li> <p>H. Liu, A. T. Neal, Z. Zhu, X. Xu , D. Tomanek and P. D. Ye, ACS Nano 8, 4033 (2014) \u21a9</p> </li> <li> <p>A. Ferreira and E. R. Mucciolo, Phys. Rev. Lett. 115, 106601 (2015).\u00a0\u21a9</p> </li> </ol>"},{"location":"documentation/more_examples/additional_examples/","title":"About Examples-dir","text":"<p>Info</p> <p>This file describes the contents of the <code>kite/examples/</code>-folder.</p>"},{"location":"documentation/more_examples/additional_examples/#kite-scripts","title":"KITE Scripts","text":"<p>This folder contains various scripts with examples showing the functionalities of the KITE library. To execute a script, run</p> <pre><code>python3 example.py\n../build/KITEx example-output.h5\n../build/KITE-tools example-output.h5\n</code></pre> <p>Several examples are given, including</p> <p>A simple DOS calculation of various systems, such as</p> <ul> <li>Checkerboard lattice</li> <li>Graphene</li> <li>Cubic lattice</li> </ul> <p>Two types of disorder:</p> <ul> <li>On-site (uncorrelated) disorder</li> <li>Vacancies</li> </ul> <p>More advanced examples covering:</p> <ul> <li>Optical conductivity</li> <li>XX/YY conductivity</li> <li>Weyl semi-metal calculations</li> <li>Fu-Kane-Mele model calculations</li> </ul> <p>These Python scripts return a HDF5-file. These files can then be passed to the KITEx-executable to perform the core calculation. Finally, the raw output data can be analyzed using the KITE-tools-executable. Depending on the type of calculation, various output files will be created in the folder where the code was executed from.</p> <p>All the results can be generated automatically by running</p> <pre><code>python3 run_all_examples.py\n</code></pre> <p>After running this command, all the examples will be executed. This can take several minutes. Besides the output files, like name-dos.dat, plots will be given for the DOS, optical conductivity and DC conductivity.</p> <p>To clean up the folder after running all the examples, execute the following commands</p> <pre><code>python3\n&gt;&gt;&gt; import run_all_examples\n&gt;&gt;&gt; run_all_examples.clean()\n&gt;&gt;&gt; exit()\n</code></pre>"},{"location":"documentation/more_examples/custom_local_potential/","title":"Custom Local Potential","text":"<p>Info</p> <p>This file describes the contents of the <code>kite/examples/custom_local_potential/</code>-folder.</p> <p>This example shows how to use the custom local potential functionality in KITE. </p> <p>Begin by defining the local energy function that you want to use. This is a function that takes as arguments the position (\\(x\\), \\(y\\)) (in 2D) or (\\(x\\), \\(y\\), \\(z\\)) (in 3D) and orbital <code>\"orb\"</code> and returns the value of the local energy at that position and orbital. This function is defined by the user in a simple cpp file <code>aux.cpp</code>, which is then compiled into a shared library to be used by KITE <code>libaux.so.1</code>. To force KITE to use the function defined by the user, the file <code>/lib/libaux.so.1</code> should be replaced by our custom shared library, and the flag <code>custom_local=True</code> must be used in the Python configuration script. By default, this flag is set to <code>False</code>. </p>"},{"location":"documentation/more_examples/custom_local_potential/#1-compiling-and-replacing-the-default-library","title":"1. Compiling and replacing the default library","text":"<p>Begin by compiling the c++ file into a shared library by executing the following lines:</p> <pre><code>g++ -Wall -fPIC -c aux.cpp\ng++ -shared -Wl,-soname,libaux.so.1 -o libaux.so aux.o\n</code></pre> <p>The first line compiles the <code>aux.cpp</code> file and the second generates the shared library from the compiled object. Next, replace the default shared library file in the <code>/lib</code> folder by the library that we just built:</p> <pre><code>rm ../../lib/libaux.so.1\ncp libaux.so ../../lib/libaux.so.1\n</code></pre> <p>The file <code>libaux.so.1</code> is the file that KITE will search for. Now, the next time that KITE runs, it will use the library we just built.</p>"},{"location":"documentation/more_examples/custom_local_potential/#2-running-the-example","title":"2. Running the example","text":"<p>The rest proceeds as usual. Use Python to generate the configuration file, run the KITE executable on that file and run KITE-tools on the same file again:</p> <pre><code>python config.py\n../../build/KITEx config.h5\n../../tools/build/KITE-tools config.h5\n</code></pre> <p>There is an extra flag in the configuration file <code>custom_local_print=True</code>, which tells KITE to generate the files <code>local_potentialX.dat</code>. By default, this flag is set to <code>False</code>. These files contain the potential as a function of position for all the lattice points used by KITE (one file per thread). These files can be further processed to generate a color plot of the potential for each orbital:</p> <pre><code>python3 test_potential.py\n</code></pre>"},{"location":"documentation/more_examples/custom_local_potential/#3-finalizing","title":"3. Finalizing","text":"<p>Due to the above, the default shared library used by KITE in <code>/lib</code> has been changed. If the flag <code>custom_local</code>\" is unspecified, or set to <code>False</code>, KITE will simply ignore this library, but if it is set to <code>True</code>, KITE will always use the shared library that was built in this example. If the user wants to restore the original library, a backup should be used, or the following three lines can be executed inside the <code>/lib</code> folder:</p> <pre><code>g++ -Wall -fPIC -c aux.cpp \ng++ -shared -Wl,-soname,libaux.so.1 -o libaux.so aux.o\nln -sf libaux.so libaux.so.1\n</code></pre>"},{"location":"documentation/more_examples/large_systems/","title":"Large Systems","text":"<p>So far, we have considered several examples which can be reproduced on a standard desktop computer.  However, the main purpose of creating KITE was to build a flexible software for systems exceeding billions of atoms (which is key to achieve high-energy resolution). Hence, in the following tutorial we will tackle the simulation of real-size 2D crystals with lateral dimensions in the micrometer range. </p>"},{"location":"documentation/more_examples/large_systems/#graphene-lattice-with-vacancy-disorder","title":"Graphene lattice with vacancy disorder","text":"<p>We used KITE to simulate two disordered graphene flakes, having more than <code>8.9</code> (giant) and <code>0.5</code> (large) billion of atoms. The concentration of vacancy defects is <code>0.1%</code>, while the number of moments used in the calculation is <code>15000</code>. The two plots below show the impact of vacancy-induced zero energy modes on the average density of states (ADoS). The system in plot <code>a)</code> has a size of <code>l1 = 65536; l2=65536</code>, while in plot <code>b)</code> , <code>l1 = 8064; l2=8192</code>. The dashed curve represents the ADoS of pristine graphene and the solid curves show the ADoS of disorder graphene for different resolutions: yellow (20 meV), blue (10 meV), green (5 meV), purple (1 meV).</p> <p>There is an important difference in the two plots which is related to the lattice size. The limiting factor for observing fine details in the ADoS (and other typical KITE functions) is the mean level spacing, which is limited by the system size. This can be appreciated when attempting to simulate a relatively small system with a high energy resolution, as in the case of plot <code>b)</code>  with 1 meV resolution:  the spurious oscillations in the ADoS indicate that the discrete nature of the energy spectrum is being resolved. Probing a small system with high resolution can result in non-physical effects. Working with high resolutions (and consequently large systems) is especially important when dealing with localization and other quantum criticality problems<sup>1</sup>. g If you would like to reproduce these results, we recommend running the script <code>dos_vacancies.py</code> in the Github repository. Note that the RAM requirements for running DOS on the large system specified above requires <code>~5GB</code> of RAM memory and around 20 minutes on a compute node with 28 cores.</p> <p></p>"},{"location":"documentation/more_examples/large_systems/#moire-pattern","title":"Moir\u00e9 pattern","text":"<p>The second example is a large twisted bilayer graphene lattice in the clean limit, with the number of atoms exceeding <code>~0.7</code> billion. The model Hamiltonian <sup>2</sup> of such a system has a much larger coordination number (average number of neighbors per site).  The key parameter when estimating the execution time (and the memory requirements) is the \"effective\" size, which is the product of the number of sites and the coordination number.</p> <p>Depending on the rotation angle between adjacent layers, the resulting moir\u00e9 pattern may strongly impact the low-energy electrons. For high twist angles, the two layers are effectively decoupled and the van Hove singularities (VHSs) are far from the charge neutrality point. As the angle is decreased, the VHSs \"move\" towards lower energies and eventually merge, forming flat bands. This phenomenon occurs for the so-called \"magic\" angles, which are of great interest as they provide a rich playground to study unconventional states of matter ranging from Mott insulators to superconductors.</p> <p>Plots <code>a)</code> and <code>b)</code> show the ADoS for rotation angles of <code>2.005</code> (low) and <code>13.741</code> (high) degrees, respectively. As in the previous case of disordered graphene, the finer spectral details become visible when performing computations with a good resolution. High twist angles give rise to properties more similar to Bernal-stacked bilayer graphene. At low angles, the spectrum is much richer, and the linear spectrum of the two layers is fully changed due to the induced Moir\u00e9 pattern. Apart from a slight electron-hole asymmetry, at high energies, the ADoS in both cases follow that of monolayer graphene. Note the appearance of small spurious oscillations when the ADoS is reconstructed from the Chebyshev moments with too fine a broadening (1 meV). Interestingly, the small twist-angle system has more states in the low-energy region of the spectrum than the large-twist angle system, consistent with a smaller mean level spacing.  Thus, for high energy resolution (1 meV) in plot <code>b)</code> we can see the appearance of the aforementioned oscillations, while the same ADoS plot in plot <code>a)</code> looks very smooth near the charge neutrality point. When considering an arbitrary system, both the requested energy resolution and the system size will be reflected on the level of details one is able to distinguish.</p> <p></p> <p>Below, you can find a script used to configure the KITE model for twisted bilayer graphene. The lattice of twisted bilayer graphene (especially at low rotation angles) has a much more complex unit cell compared to common Bernal-stacked bilayer graphene, where for an arbitrary twist angle, one does not have access to all relevant neighboring sites using a small set of connecting vectors. A more advanced algorithm is needed for finding the unit cell connections <sup>3</sup>. In this example, we use a pre-defined lattice object that is loaded with a simple command:</p> <pre><code>    # define the angle\n    angle = 21.787 # or 13.174, 7.341, 2.005\n    # define the name of the pb.Lattice object\n    name = 'lattice_tblg_{:.3f}'.format(angle)\n    #load the lattice\n    lattice = pb.load(name)\n</code></pre> <p>Now, you can continue with specifying the other configuration settings as explained in Getting Started.</p> <p>The full script can be downloaded here; see also the KITE paper examples' folder.</p> <ol> <li> <p>A. Ferreira and E. Mucciolo, Phys. Rev. Lett. 115, 106601 (2015) \u21a9</p> </li> <li> <p>P. Moon and M. Koshino, Phys. Rev. B 85, 195458 (2012).\u00a0\u21a9</p> </li> <li> <p>S. M. Jo\u00e3o et al, R. Soc. open sci. 7, 191809 (2020) \u21a9</p> </li> </ol>"},{"location":"documentation/more_examples/paper/","title":"Examples from KITE's Paper","text":"<p>Info</p> <p>This file describes the contents of the <code>kite/examples/paper/</code>-folder.</p>"},{"location":"documentation/more_examples/paper/#examples-from-the-kite-paper","title":"Examples from the KITE paper","text":"<p>In the subdirectories, you can find the scripts to generate the figures from the KITE-paper.</p>"}]}